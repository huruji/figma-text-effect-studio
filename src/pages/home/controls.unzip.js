function TextEditorControls() {
  return {
    _0x2a246e: [{
      id: "tt-text-textarea",
      objPath: "text",
      events: ["input"]
    }, {
      id: "tt-font-size-input",
      objPath: "font.size",
      events: ["input"]
    }, {
      id: "tt-font-src-input",
      objPath: "font.src",
      events: ["input", "change"]
    }, {
      id: "tt-font-name-input",
      objPath: "font.name",
      events: ["input", "change"]
    }, {
      id: "tt-font-weight-input",
      objPath: "font.weight",
      events: ["change"]
    }, {
      id: "tt-letter-spacing-input",
      objPath: "letterSpacing",
      events: ["input"]
    }, {
      id: "tt-merge-gradients-input",
      objPath: "mergeGradients",
      events: ["change"]
    }, {
      id: "tt-line-height-input",
      objPath: "lineHeight",
      events: ["input", "change"]
    }, {
      id: "tt-rotate-input",
      objPath: "rotate",
      events: ["input"]
    }, {
      id: "tt-align-input",
      objPath: "align",
      events: ["change"]
    }, {
      id: "tt-lettering-active-input",
      objPath: "lettering.active",
      events: ["change"]
    }, {
      id: "tt-lettering-reverse-overlap-letters-input",
      objPath: "lettering.reverseOverlap.letters",
      events: ["change"]
    }, {
      id: "tt-lettering-reverse-overlap-lines-input",
      objPath: "lettering.reverseOverlap.lines",
      events: ["change"]
    }, {
      id: "tt-lettering-boggle-active-input",
      objPath: "lettering.boggle.active",
      events: ["change"]
    }, {
      id: "tt-lettering-boggle-angle-input",
      objPath: "lettering.boggle.angle",
      events: ["input"]
    }, {
      id: "tt-lettering-boggle-amplitude-input",
      objPath: "lettering.boggle.amplitude",
      events: ["input"]
    }, {
      id: "tt-lettering-shadow-active-input",
      objPath: "lettering.shadow.active",
      events: ["change"]
    }, {
      id: "tt-lettering-shadow-size-input",
      objPath: "lettering.shadow.size",
      events: ["input"]
    }, {
      id: "tt-lettering-shadow-angle-input",
      objPath: "lettering.shadow.angle",
      events: ["input"]
    }, {
      id: "tt-lettering-shadow-distance-input",
      objPath: "lettering.shadow.distance",
      events: ["input"]
    }, {
      id: "tt-lettering-shadow-fill-color-input",
      objPath: "lettering.shadow.fill.color",
      events: ["input"]
    }, {
      id: "tt-lettering-shadow-fill-alpha-input",
      objPath: "lettering.shadow.fill.alpha",
      events: ["input"]
    }, {
      id: "tt-lettering-blendmode-input",
      objPath: "lettering.blendmode",
      events: ["input"]
    }, {
      id: "tt-fill-active-input",
      objPath: "fill.active",
      events: ["change"]
    }, {
      id: "tt-fill-color-input",
      objPath: "fill.color",
      events: ["input"]
    }, {
      id: "tt-fill-alpha-input",
      objPath: "fill.alpha",
      events: ["input"]
    }, {
      id: "tt-fill-gradient-active-input",
      objPath: "fill.gradient.active",
      events: ["change"]
    }, {
      id: "tt-fill-gradient-angle-input",
      objPath: "fill.gradient.angle",
      events: ["input"]
    }, {
      id: "tt-fill-gradient-colors-input",
      objPath: "fill.gradient.colors",
      events: ["change"]
    }, {
      id: "tt-fill-palette-active-input",
      objPath: "fill.palette.active",
      events: ["change"]
    }, {
      id: "tt-fill-palette-lettering-method-input",
      objPath: "fill.palette.lettering.method",
      events: ["input"]
    }, {
      id: "tt-fill-texture-active-input",
      objPath: "fill.texture.active",
      events: ["change"]
    }, {
      id: "tt-fill-texture-import-input",
      objPath: "fill.texture.src",
      events: ["change"]
    }, {
      id: "tt-fill-texture-alpha-input",
      objPath: "fill.texture.alpha",
      events: ["input"]
    }, {
      id: "tt-fill-texture-blendmode-input",
      objPath: "fill.texture.blendmode",
      events: ["input"]
    }, {
      id: "tt-fill-texture-repeat-input",
      objPath: "fill.texture.repeat",
      events: ["input"]
    }, {
      id: "tt-fill-texture-position-input",
      objPath: "fill.texture.position",
      events: ["input"]
    }, {
      id: "tt-fill-texture-size-input",
      objPath: "fill.texture.size",
      events: ["input"]
    }, {
      id: "tt-fill-texture-lettering-input",
      objPath: "fill.texture.lettering",
      events: ["change"]
    }, {
      id: "tt-distort-arc-angle-input",
      objPath: "distort.arc.angle",
      events: ["change"]
    }, {
      id: "tt-outline-first-active-input",
      objPath: "outline.first.active",
      events: ["change"]
    }, {
      id: "tt-outline-first-width-input",
      objPath: "outline.first.width",
      events: ["input"]
    }, {
      id: "tt-outline-first-fill-color-input",
      objPath: "outline.first.fill.color",
      events: ["input"]
    }, {
      id: "tt-outline-first-dash-input",
      objPath: "outline.first.dash",
      events: ["input"]
    }, {
      id: "tt-outline-first-join-input",
      objPath: "outline.first.join",
      events: ["change"]
    }, {
      id: "tt-outline-first-fill-alpha-input",
      objPath: "outline.first.fill.alpha",
      events: ["input"]
    }, {
      id: "tt-outline-first-fill-gradient-active-input",
      objPath: "outline.first.fill.gradient.active",
      events: ["change"]
    }, {
      id: "tt-outline-first-fill-gradient-colors-input",
      objPath: "outline.first.fill.gradient.colors",
      events: ["change"]
    }, {
      id: "tt-outline-first-fill-gradient-angle-input",
      objPath: "outline.first.fill.gradient.angle",
      events: ["input"]
    }, {
      id: "tt-outline-first-fill-texture-active-input",
      objPath: "outline.first.fill.texture.active",
      events: ["change"]
    }, {
      id: "tt-outline-first-fill-texture-import-input",
      objPath: "outline.first.fill.texture.src",
      events: ["change"]
    }, {
      id: "tt-outline-first-fill-texture-alpha-input",
      objPath: "outline.first.fill.texture.alpha",
      events: ["input"]
    }, {
      id: "tt-outline-first-fill-texture-blendmode-input",
      objPath: "outline.first.fill.texture.blendmode",
      events: ["input"]
    }, {
      id: "tt-outline-first-fill-texture-repeat-input",
      objPath: "outline.first.fill.texture.repeat",
      events: ["input"]
    }, {
      id: "tt-outline-first-fill-texture-position-input",
      objPath: "outline.first.fill.texture.position",
      events: ["input"]
    }, {
      id: "tt-outline-first-fill-texture-size-input",
      objPath: "outline.first.fill.texture.size",
      events: ["input"]
    }, {
      id: "tt-outline-first-fill-texture-lettering-input",
      objPath: "outline.first.fill.texture.lettering",
      events: ["change"]
    }, {
      id: "tt-outline-first-fill-palette-active-input",
      objPath: "outline.first.fill.palette.active",
      events: ["change"]
    }, {
      id: "tt-outline-first-fill-palette-lettering-method-input",
      objPath: "outline.first.fill.palette.lettering.method",
      events: ["change"]
    }, {
      id: "tt-outline-second-active-input",
      objPath: "outline.second.active",
      events: ["change"]
    }, {
      id: "tt-outline-second-width-input",
      objPath: "outline.second.width",
      events: ["input"]
    }, {
      id: "tt-outline-second-fill-color-input",
      objPath: "outline.second.fill.color",
      events: ["input"]
    }, {
      id: "tt-outline-second-dash-input",
      objPath: "outline.second.dash",
      events: ["input"]
    }, {
      id: "tt-outline-second-join-input",
      objPath: "outline.second.join",
      events: ["change"]
    }, {
      id: "tt-outline-second-fill-alpha-input",
      objPath: "outline.second.fill.alpha",
      events: ["input"]
    }, {
      id: "tt-outline-second-fill-gradient-active-input",
      objPath: "outline.second.fill.gradient.active",
      events: ["change"]
    }, {
      id: "tt-outline-second-fill-gradient-colors-input",
      objPath: "outline.second.fill.gradient.colors",
      events: ["change"]
    }, {
      id: "tt-outline-second-fill-gradient-angle-input",
      objPath: "outline.second.fill.gradient.angle",
      events: ["input"]
    }, {
      id: "tt-outline-second-fill-texture-active-input",
      objPath: "outline.second.fill.texture.active",
      events: ["change"]
    }, {
      id: "tt-outline-second-fill-texture-import-input",
      objPath: "outline.second.fill.texture.src",
      events: ["change"]
    }, {
      id: "tt-outline-second-fill-texture-alpha-input",
      objPath: "outline.second.fill.texture.alpha",
      events: ["input"]
    }, {
      id: "tt-outline-second-fill-texture-blendmode-input",
      objPath: "outline.second.fill.texture.blendmode",
      events: ["input"]
    }, {
      id: "tt-outline-second-fill-texture-repeat-input",
      objPath: "outline.second.fill.texture.repeat",
      events: ["input"]
    }, {
      id: "tt-outline-second-fill-texture-position-input",
      objPath: "outline.second.fill.texture.position",
      events: ["input"]
    }, {
      id: "tt-outline-second-fill-texture-size-input",
      objPath: "outline.second.fill.texture.size",
      events: ["input"]
    }, {
      id: "tt-outline-second-fill-texture-lettering-input",
      objPath: "outline.second.fill.texture.lettering",
      events: ["change"]
    }, {
      id: "tt-outline-second-fill-palette-active-input",
      objPath: "outline.second.fill.palette.active",
      events: ["change"]
    }, {
      id: "tt-outline-second-fill-palette-lettering-method-input",
      objPath: "outline.second.fill.palette.lettering.method",
      events: ["change"]
    }, {
      id: "tt-outline-global-active-input",
      objPath: "outline.global.active",
      events: ["change"]
    }, {
      id: "tt-outline-global-width-input",
      objPath: "outline.global.width",
      events: ["input"]
    }, {
      id: "tt-outline-global-join-input",
      objPath: "outline.global.join",
      events: ["change"]
    }, {
      id: "tt-outline-global-fill-color-input",
      objPath: "outline.global.fill.color",
      events: ["input"]
    }, {
      id: "tt-outline-global-fill-alpha-input",
      objPath: "outline.global.fill.alpha",
      events: ["input"]
    }, {
      id: "tt-outline-global-fill-gradient-active-input",
      objPath: "outline.global.fill.gradient.active",
      events: ["change"]
    }, {
      id: "tt-outline-global-fill-gradient-colors-input",
      objPath: "outline.global.fill.gradient.colors",
      events: ["change"]
    }, {
      id: "tt-outline-global-fill-gradient-angle-input",
      objPath: "outline.global.fill.gradient.angle",
      events: ["input"]
    }, {
      id: "tt-outline-global-mask-input",
      objPath: "outline.global.mask",
      events: ["change"]
    }, {
      id: "tt-outline-global-projection-input",
      objPath: "outline.global.projection",
      events: ["change"]
    }, {
      id: "tt-outline-global-vector-input",
      objPath: "outline.global.vector",
      events: ["change"]
    }, {
      id: "tt-outline-global-shadow-active-input",
      objPath: "outline.global.shadow.active",
      events: ["change"]
    }, {
      id: "tt-outline-global-fill-texture-active-input",
      objPath: "outline.global.fill.texture.active",
      events: ["change"]
    }, {
      id: "tt-outline-global-fill-texture-import-input",
      objPath: "outline.global.fill.texture.src",
      events: ["change"]
    }, {
      id: "tt-outline-global-fill-texture-alpha-input",
      objPath: "outline.global.fill.texture.alpha",
      events: ["input"]
    }, {
      id: "tt-outline-global-fill-texture-blendmode-input",
      objPath: "outline.global.fill.texture.blendmode",
      events: ["input"]
    }, {
      id: "tt-outline-global-fill-texture-repeat-input",
      objPath: "outline.global.fill.texture.repeat",
      events: ["input"]
    }, {
      id: "tt-outline-global-fill-texture-position-input",
      objPath: "outline.global.fill.texture.position",
      events: ["input"]
    }, {
      id: "tt-outline-global-fill-texture-size-input",
      objPath: "outline.global.fill.texture.size",
      events: ["input"]
    }, {
      id: "tt-outline-global2-active-input",
      objPath: "outline.global2.active",
      events: ["change"]
    }, {
      id: "tt-outline-global2-width-input",
      objPath: "outline.global2.width",
      events: ["input"]
    }, {
      id: "tt-outline-global2-join-input",
      objPath: "outline.global2.join",
      events: ["change"]
    }, {
      id: "tt-outline-global2-fill-color-input",
      objPath: "outline.global2.fill.color",
      events: ["input"]
    }, {
      id: "tt-outline-global2-fill-alpha-input",
      objPath: "outline.global2.fill.alpha",
      events: ["input"]
    }, {
      id: "tt-outline-global2-fill-gradient-active-input",
      objPath: "outline.global2.fill.gradient.active",
      events: ["change"]
    }, {
      id: "tt-outline-global2-fill-gradient-colors-input",
      objPath: "outline.global2.fill.gradient.colors",
      events: ["change"]
    }, {
      id: "tt-outline-global2-fill-gradient-angle-input",
      objPath: "outline.global2.fill.gradient.angle",
      events: ["input"]
    }, {
      id: "tt-outline-global2-mask-input",
      objPath: "outline.global2.mask",
      events: ["change"]
    }, {
      id: "tt-outline-global2-projection-input",
      objPath: "outline.global2.projection",
      events: ["change"]
    }, {
      id: "tt-outline-global2-vector-input",
      objPath: "outline.global2.vector",
      events: ["change"]
    }, {
      id: "tt-outline-global2-shadow-active-input",
      objPath: "outline.global2.shadow.active",
      events: ["change"]
    }, {
      id: "tt-outline-global2-fill-texture-active-input",
      objPath: "outline.global2.fill.texture.active",
      events: ["change"]
    }, {
      id: "tt-outline-global2-fill-texture-import-input",
      objPath: "outline.global2.fill.texture.src",
      events: ["change"]
    }, {
      id: "tt-outline-global2-fill-texture-alpha-input",
      objPath: "outline.global2.fill.texture.alpha",
      events: ["input"]
    }, {
      id: "tt-outline-global2-fill-texture-blendmode-input",
      objPath: "outline.global2.fill.texture.blendmode",
      events: ["input"]
    }, {
      id: "tt-outline-global2-fill-texture-repeat-input",
      objPath: "outline.global2.fill.texture.repeat",
      events: ["input"]
    }, {
      id: "tt-outline-global2-fill-texture-position-input",
      objPath: "outline.global2.fill.texture.position",
      events: ["input"]
    }, {
      id: "tt-outline-global2-fill-texture-size-input",
      objPath: "outline.global2.fill.texture.size",
      events: ["input"]
    }, {
      id: "tt-depth-active-input",
      objPath: "depth.active",
      events: ["change"]
    }, {
      id: "tt-depth-length-input",
      objPath: "depth.length",
      events: ["input"]
    }, {
      id: "tt-depth-angle-input",
      objPath: "depth.angle",
      events: ["input"]
    }, {
      id: "tt-depth-fill-color-input",
      objPath: "depth.fill.color",
      events: ["input"]
    }, {
      id: "tt-depth-fill-alpha-input",
      objPath: "depth.fill.alpha",
      events: ["input"]
    }, {
      id: "tt-depth-fill-merge-alpha-input",
      objPath: "depth.fill.mergeAlpha",
      events: ["input"]
    }, {
      id: "tt-depth-fill-gradient-active-input",
      objPath: "depth.fill.gradient.active",
      events: ["change"]
    }, {
      id: "tt-depth-fill-gradient-colors-input",
      objPath: "depth.fill.gradient.colors",
      events: ["change"]
    }, {
      id: "tt-depth-fill-gradient-angle-input",
      objPath: "depth.fill.gradient.angle",
      events: ["input"]
    }, {
      id: "tt-depth-fill-gradient-type-input",
      objPath: "depth.fill.gradient.type",
      events: ["change"]
    }, {
      id: "tt-depth-fill-texture-active-input",
      objPath: "depth.fill.texture.active",
      events: ["change"]
    }, {
      id: "tt-depth-fill-texture-import-input",
      objPath: "depth.fill.texture.src",
      events: ["change"]
    }, {
      id: "tt-depth-fill-texture-alpha-input",
      objPath: "depth.fill.texture.alpha",
      events: ["input"]
    }, {
      id: "tt-depth-fill-texture-blendmode-input",
      objPath: "depth.fill.texture.blendmode",
      events: ["input"]
    }, {
      id: "tt-depth-fill-texture-repeat-input",
      objPath: "depth.fill.texture.repeat",
      events: ["input"]
    }, {
      id: "tt-depth-fill-texture-position-input",
      objPath: "depth.fill.texture.position",
      events: ["input"]
    }, {
      id: "tt-depth-fill-texture-size-input",
      objPath: "depth.fill.texture.size",
      events: ["input"]
    }, {
      id: "tt-depth2-active-input",
      objPath: "depth2.active",
      events: ["change"]
    }, {
      id: "tt-depth2-length-input",
      objPath: "depth2.length",
      events: ["input"]
    }, {
      id: "tt-depth2-angle-input",
      objPath: "depth2.angle",
      events: ["input"]
    }, {
      id: "tt-depth2-fill-color-input",
      objPath: "depth2.fill.color",
      events: ["input"]
    }, {
      id: "tt-depth2-fill-alpha-input",
      objPath: "depth2.fill.alpha",
      events: ["input"]
    }, {
      id: "tt-depth2-fill-merge-alpha-input",
      objPath: "depth2.fill.mergeAlpha",
      events: ["input"]
    }, {
      id: "tt-depth2-fill-gradient-active-input",
      objPath: "depth2.fill.gradient.active",
      events: ["change"]
    }, {
      id: "tt-depth2-fill-gradient-colors-input",
      objPath: "depth2.fill.gradient.colors",
      events: ["change"]
    }, {
      id: "tt-depth2-fill-gradient-angle-input",
      objPath: "depth2.fill.gradient.angle",
      events: ["input"]
    }, {
      id: "tt-depth2-fill-gradient-type-input",
      objPath: "depth2.fill.gradient.type",
      events: ["change"]
    }, {
      id: "tt-depth2-fill-texture-active-input",
      objPath: "depth2.fill.texture.active",
      events: ["change"]
    }, {
      id: "tt-depth2-fill-texture-import-input",
      objPath: "depth2.fill.texture.src",
      events: ["change"]
    }, {
      id: "tt-depth2-fill-texture-alpha-input",
      objPath: "depth2.fill.texture.alpha",
      events: ["input"]
    }, {
      id: "tt-depth2-fill-texture-blendmode-input",
      objPath: "depth2.fill.texture.blendmode",
      events: ["input"]
    }, {
      id: "tt-depth2-fill-texture-repeat-input",
      objPath: "depth2.fill.texture.repeat",
      events: ["input"]
    }, {
      id: "tt-depth2-fill-texture-position-input",
      objPath: "depth2.fill.texture.position",
      events: ["input"]
    }, {
      id: "tt-depth2-fill-texture-size-input",
      objPath: "depth2.fill.texture.size",
      events: ["input"]
    }, {
      id: "tt-bevel-inner-active-input",
      objPath: "bevel.inner.active",
      events: ["change"]
    }, {
      id: "tt-bevel-inner-size-input",
      objPath: "bevel.inner.size",
      events: ["input"]
    }, {
      id: "tt-bevel-inner-smoothing-input",
      objPath: "bevel.inner.smoothing",
      events: ["input"]
    }, {
      id: "tt-bevel-inner-soften-input",
      objPath: "bevel.inner.soften",
      events: ["input"]
    }, {
      id: "tt-bevel-inner-angle-input",
      objPath: "bevel.inner.angle",
      events: ["input"]
    }, {
      id: "tt-bevel-inner-highlight-alpha-input",
      objPath: "bevel.inner.highlight.alpha",
      events: ["input"]
    }, {
      id: "tt-bevel-inner-highlight-color-input",
      objPath: "bevel.inner.highlight.color",
      events: ["input"]
    }, {
      id: "tt-bevel-inner-highlight-blendmode-input",
      objPath: "bevel.inner.highlight.blendmode",
      events: ["input"]
    }, {
      id: "tt-bevel-inner-shadow-alpha-input",
      objPath: "bevel.inner.shadow.alpha",
      events: ["input"]
    }, {
      id: "tt-bevel-inner-shadow-color-input",
      objPath: "bevel.inner.shadow.color",
      events: ["input"]
    }, {
      id: "tt-bevel-inner-shadow-blendmode-input",
      objPath: "bevel.inner.shadow.blendmode",
      events: ["input"]
    }, {
      id: "tt-shadow-outer-active-input",
      objPath: "shadow.outer.active",
      events: ["change"]
    }, {
      id: "tt-shadow-outer-size-input",
      objPath: "shadow.outer.size",
      events: ["input"]
    }, {
      id: "tt-shadow-outer-strength-input",
      objPath: "shadow.outer.strength",
      events: ["input"]
    }, {
      id: "tt-shadow-outer-angle-input",
      objPath: "shadow.outer.angle",
      events: ["input"]
    }, {
      id: "tt-shadow-outer-distance-input",
      objPath: "shadow.outer.distance",
      events: ["input"]
    }, {
      id: "tt-shadow-outer-mask-input",
      objPath: "shadow.outer.mask",
      events: ["change"]
    }, {
      id: "tt-shadow-outer-fill-color-input",
      objPath: "shadow.outer.fill.color",
      events: ["input"]
    }, {
      id: "tt-shadow-outer-fill-alpha-input",
      objPath: "shadow.outer.fill.alpha",
      events: ["input"]
    }, {
      id: "tt-shadow-outer-fill-gradient-active-input",
      objPath: "shadow.outer.fill.gradient.active",
      events: ["change"]
    }, {
      id: "tt-shadow-outer-fill-gradient-colors-input",
      objPath: "shadow.outer.fill.gradient.colors",
      events: ["change"]
    }, {
      id: "tt-shadow-outer-fill-gradient-angle-input",
      objPath: "shadow.outer.fill.gradient.angle",
      events: ["input"]
    }, {
      id: "tt-shadow-outer2-active-input",
      objPath: "shadow.outer2.active",
      events: ["change"]
    }, {
      id: "tt-shadow-outer2-size-input",
      objPath: "shadow.outer2.size",
      events: ["input"]
    }, {
      id: "tt-shadow-outer2-strength-input",
      objPath: "shadow.outer2.strength",
      events: ["input"]
    }, {
      id: "tt-shadow-outer2-angle-input",
      objPath: "shadow.outer2.angle",
      events: ["input"]
    }, {
      id: "tt-shadow-outer2-distance-input",
      objPath: "shadow.outer2.distance",
      events: ["input"]
    }, {
      id: "tt-shadow-outer2-mask-input",
      objPath: "shadow.outer2.mask",
      events: ["change"]
    }, {
      id: "tt-shadow-outer2-fill-color-input",
      objPath: "shadow.outer2.fill.color",
      events: ["input"]
    }, {
      id: "tt-shadow-outer2-fill-alpha-input",
      objPath: "shadow.outer2.fill.alpha",
      events: ["input"]
    }, {
      id: "tt-shadow-outer2-fill-gradient-active-input",
      objPath: "shadow.outer2.fill.gradient.active",
      events: ["change"]
    }, {
      id: "tt-shadow-outer2-fill-gradient-colors-input",
      objPath: "shadow.outer2.fill.gradient.colors",
      events: ["change"]
    }, {
      id: "tt-shadow-outer2-fill-gradient-angle-input",
      objPath: "shadow.outer2.fill.gradient.angle",
      events: ["input"]
    }, {
      id: "tt-shadow-inner-active-input",
      objPath: "shadow.inner.active",
      events: ["change"]
    }, {
      id: "tt-shadow-inner-size-input",
      objPath: "shadow.inner.size",
      events: ["input"]
    }, {
      id: "tt-shadow-inner-strength-input",
      objPath: "shadow.inner.strength",
      events: ["input"]
    }, {
      id: "tt-shadow-inner-alpha-input",
      objPath: "shadow.inner.alpha",
      events: ["input"]
    }, {
      id: "tt-shadow-inner-color-input",
      objPath: "shadow.inner.color",
      events: ["input"]
    }, {
      id: "tt-shadow-inner-distance-input",
      objPath: "shadow.inner.distance",
      events: ["input"]
    }, {
      id: "tt-shadow-inner-angle-input",
      objPath: "shadow.inner.angle",
      events: ["input"]
    }, {
      id: "tt-shadow-inner-offset-input",
      objPath: "shadow.inner.offset",
      events: ["input"]
    }, {
      id: "tt-shadow-inner-erosion-size-input",
      objPath: "shadow.inner.erosion.size",
      events: ["input"]
    }, {
      id: "tt-shadow-inner-blendmode-input",
      objPath: "shadow.inner.blendmode",
      events: ["input"]
    }, {
      id: "tt-shadow-inner2-active-input",
      objPath: "shadow.inner2.active",
      events: ["change"]
    }, {
      id: "tt-shadow-inner2-size-input",
      objPath: "shadow.inner2.size",
      events: ["input"]
    }, {
      id: "tt-shadow-inner2-strength-input",
      objPath: "shadow.inner2.strength",
      events: ["input"]
    }, {
      id: "tt-shadow-inner2-alpha-input",
      objPath: "shadow.inner2.alpha",
      events: ["input"]
    }, {
      id: "tt-shadow-inner2-color-input",
      objPath: "shadow.inner2.color",
      events: ["input"]
    }, {
      id: "tt-shadow-inner2-distance-input",
      objPath: "shadow.inner2.distance",
      events: ["input"]
    }, {
      id: "tt-shadow-inner2-angle-input",
      objPath: "shadow.inner2.angle",
      events: ["input"]
    }, {
      id: "tt-shadow-inner2-offset-input",
      objPath: "shadow.inner2.offset",
      events: ["input"]
    }, {
      id: "tt-shadow-inner2-erosion-size-input",
      objPath: "shadow.inner2.erosion.size",
      events: ["input"]
    }, {
      id: "tt-shadow-inner2-blendmode-input",
      objPath: "shadow.inner2.blendmode",
      events: ["input"]
    }, {
      id: "tt-background-active-input",
      objPath: "background.active",
      events: ["change"]
    }, {
      id: "tt-background-fill-color-input",
      objPath: "background.fill.color",
      events: ["input"]
    }, {
      id: "tt-background-fill-gradient-active-input",
      objPath: "background.fill.gradient.active",
      events: ["change"]
    }, {
      id: "tt-background-fill-alpha-input",
      objPath: "background.fill.alpha",
      events: ["input"]
    }, {
      id: "tt-background-fill-gradient-colors-input",
      objPath: "background.fill.gradient.colors",
      events: ["change"]
    }, {
      id: "tt-background-fill-gradient-angle-input",
      objPath: "background.fill.gradient.angle",
      events: ["input"]
    }, {
      id: "tt-background-fill-gradient-type-input",
      objPath: "background.fill.gradient.type",
      events: ["change"]
    }, {
      id: "tt-background-composite-input",
      objPath: "background.composite",
      events: ["change"]
    }, {
      id: "tt-background-fill-image-active-input",
      objPath: "background.fill.image.active",
      events: ["change"]
    }, {
      id: "tt-background-fill-image-import-input",
      objPath: "background.fill.image.src",
      events: ["change"]
    }, {
      id: "tt-background-fill-image-size-input",
      objPath: "background.fill.image.size",
      events: ["input"]
    }, {
      id: "tt-background-fill-image-size-custom-input",
      objPath: "background.fill.image.size.custom",
      events: ["input"]
    }, {
      id: "tt-background-fill-image-repeat-input",
      objPath: "background.fill.image.repeat",
      events: ["input"]
    }, {
      id: "tt-background-fill-image-alpha-input",
      objPath: "background.fill.image.alpha",
      events: ["input"]
    }, {
      id: "tt-icon-active-input",
      objPath: "icon.active",
      events: ["change"]
    }, {
      id: "tt-icon-import-input",
      objPath: "icon.src",
      events: ["change"]
    }, {
      id: "tt-icon-size-input",
      objPath: "icon.size",
      events: ["input"]
    }, {
      id: "tt-icon-offset-x-input",
      objPath: "icon.offset.x",
      events: ["input"]
    }, {
      id: "tt-icon-offset-y-input",
      objPath: "icon.offset.y",
      events: ["input"]
    }, {
      id: "tt-icon-position-input",
      objPath: "icon.position",
      events: ["input"]
    }, {
      id: "tt-icon-rotate-input",
      objPath: "icon.rotate",
      events: ["input"]
    }, {
      id: "tt-icon-composite-input",
      objPath: "icon.composite",
      events: ["input"]
    }, {
      id: "tt-icon-alpha-input",
      objPath: "icon.alpha",
      events: ["input"]
    }, {
      id: "tt-animation-active-input",
      objPath: "animation.active",
      events: ["change"]
    }, {
      id: "tt-animation-id-input",
      objPath: "animation.id",
      events: ["change"]
    }, {
      id: "tt-animation-duration-input",
      objPath: "animation.duration",
      events: ["change"]
    }, {
      id: "tt-animation-pause-input",
      objPath: "animation.pause",
      events: ["change"]
    }],
    _0x2b87cc: function () {
      this.tt = getById("tt");
      return this;
    },
    _0x23392d: function (t) {
      this.textEditor = t;
      this._0x5a6ea5();
      return this;
    },
    _0x5a6ea5: function () {
      const t = [[116, 101, 120, 116, 115, 116, 117, 100, 105, 111, 46, 99, 111], [116, 101, 120, 116, 115, 116, 117, 100, 105, 111, 46, 99, 111, 109], [116, 101, 120, 116, 115, 116, 117, 100, 105, 111, 46, 102, 114], [108, 111, 99, 97, 108, 104, 111, 115, 116], [108, 111, 99, 97, 108, 104, 111, 115, 116, 46, 99, 111, 109], [49, 57, 50, 46, 49, 54, 56, 46]];
      const e = new URL(window.location.href);
      let n = false;
      for (i = 0; i < t.length; i++) {
        const a = String.fromCharCode.apply(null, t[i]);
        if (e.host.indexOf(a) !== -1) {
          n = true;
          break;
        }
      }
      if (!n) {
        return -1;
      }
      if ((document.readyState === "interactive" || document.readyState === "complete") && !window.controlsInitialized) {
        window.controlsInitialized = true;
        this._0x5458f5();
        this._0x40344f();
        this._0x25aaae();
        this._0x2f5e77();
        this._0x59527b();
        this._0x4593c1();
        this._0x3a1eb0();
        this._0x59c30f();
        this._0x597ee2();
        this._0x409566();
        this._0x3225da();
        this._0xbd04e7();
        this._0x3a3054();
        this._0x551df3();
        this._0x16a825();
        this._0x343198();
        this._0x15de4f();
        this._0x2f088a();
        this._0x5434bc();
        this._0xefdd6d();
        this._0x17c1b8();
        this._0x37276a();
        this._0x5a3a27();
        this._0x2bcc22();
        this._0x5ff4f5();
        this._0xd05976();
        this._0x280c28();
        this._0x196421();
        this._0x115fb4();
        this._0x768578();
        this._0x2ca34f();
        return;
      }
      let a = this;
      document.addEventListener("DOMContentLoaded", function (t) {
        a._0x5a6ea5();
      });
    },
    _0x3b575d: {},
    on: function (t, e) {
      this._0x3b575d[t] = e;
    },
    _0x2ca34f: function (t) {
      let e = t || this.textEditor.config;
      this._0x2a246e.forEach(function (t) {
        let i = document.getElementById(t.id);
        let n = TextEditorUtil.pathResolve(t.objPath, e);
        if (i.type === "file") ;else if (t.objPath.indexOf("gradient.colors") !== -1) {
          let t;
          let e = "";
          for (let i = 0; i < n.length; i++) {
            t = TextEditorUtil.rgbToHex(n[i]);
            e += (e !== "" ? ",\n" : "") + t + " " + n[i].pos * 100 + "%";
          }
          i.value = e;
        } else if (i.type === "color" || n && n.hasOwnProperty("r")) {
          i.value = TextEditorUtil.rgbToHex(n);
        } else if (i.type === "checkbox") {
          i.checked = n === 1;
        } else {
          i.value = n;
        }
      });
      this._0x369da6.update(false);
      this._0x5050df();
      this._0x2a9467();
      this._0x3acc2a(e, false);
      this._0x319b75(e);
      this._0x488aa7(e);
      this._0x43351();
      this._0x18f97b();
      this._0x19e7bc();
      this._0x47a579();
      this._0x49ba7e(e, null);
      this._0x2fa414();
      this._0x473f29();
      this._0x214e3e(e.fill.texture, "fill-texture");
      this._0x214e3e(e.depth.fill.texture, "depth-fill-texture");
      this._0x214e3e(e.depth2.fill.texture, "depth2-fill-texture");
      this._0x214e3e(e.outline.first.fill.texture, "outline-first-fill-texture");
      this._0x214e3e(e.outline.second.fill.texture, "outline-second-fill-texture");
      this._0x214e3e(e.outline.global.fill.texture, "outline-global-fill-texture");
      this._0x214e3e(e.outline.global2.fill.texture, "outline-global2-fill-texture");
      this._0x51ac67(e);
      this._0x8d94da(e);
      this._0x5a7856(e);
      this._0x54a16e(e, false);
      this._0x353fb5(e);
      this._0xe82854(e);
      this._0x30cc85();
      this._0x5c108f(e);
      this._0x511624(e);
      this._0x552c0b();
      this._0x353990(e);
      this._0x535934();
    },
    _0x40344f: function () {
      let t = this;
      t._0x2a246e.forEach(function (e) {
        let i = document.getElementById(e.id);
        e.events.forEach(function (e) {
          i.addEventListener(e, function (e) {
            t._0x51674d(this, e);
          });
        });
      });
    },
    _0x305912: false,
    _0x51674d: function (t, e) {
      let i = this;
      let n = t.getAttribute("data-tt-option");
      let a = TextEditorUtil.cloneObject(i.textEditor.config);
      if (!i._0x305912) {
        i._0x305912 = true;
        i._0x4b91fd(a, n, t, e, function (t, e, n) {
          if (i._0x3b575d.controlChanged) {
            i._0x3b575d.controlChanged(i.textEditor, t, e, n);
          }
          i._0x305912 = false;
        });
      }
    },
    _0x353990: function (t) {
      const e = this;
      const i = this.tt.querySelector("#tt-column-text-settings");
      const n = i.querySelectorAll("[data-custom-setting]");
      for (const t of n) {
        t.remove();
      }
      if (!t.processing || !t.processing.customInputs) {
        return;
      }
      const a = t.processing.customInputs;
      const o = Object.keys(a).reverse();
      for (const t of o) {
        const n = a[t];
        const o = n.attributes;
        const l = document.createElement("input");
        l.id = "tt-custom-" + t + "input";
        l.setAttribute("data-key", t);
        for (const t in o) {
          l[t] = o[t];
        }
        if (o.type === "color") {
          l.classList.add("tt-color");
        }
        const s = document.createElement("span");
        const r = document.createElement("label");
        r.classList.add("tt-label");
        r.htmlFor = l.id;
        const d = document.createElement("div");
        d.classList.add("tt-option");
        if (o.type === "checkbox" || o.type === "color") {
          s.innerHTML = n.label;
          r.appendChild(l);
          r.appendChild(s);
          d.appendChild(r);
        } else {
          s.innerHTML = n.label + ":";
          r.appendChild(s);
          d.appendChild(r);
          d.appendChild(l);
        }
        d.setAttribute("data-custom-setting", 1);
        i.prepend(d);
        if (n.bubble) {
          l.setAttribute("data-bubble", n.bubble);
          e._0x3a3054(l);
        }
        l.addEventListener("input", function (t) {
          const i = l.getAttribute("data-key");
          const n = e.textEditor.config.processing.customInputs;
          if (this.type === "checkbox") {
            n[i].attributes.value = this.checked ? 1 : 0;
          } else {
            n[i].attributes.value = this.value;
          }
          _drawManager(e.textEditor, e.textEditor.config, {
            isPostTreatment: false,
            drawBevel: false,
            drawDistort: false,
            drawShadowErosion: false
          });
        });
      }
    },
    _0x4b91fd: function (t, e, i, n, a) {
      if (!e) {
        a(t, false, {});
        return;
      }
      const o = this;
      let l;
      let s = true;
      switch (e) {
        case "text":
          t.text = i.value;
          break;
        case "font.size":
          t.font.size = parseFloat(i.value);
          break;
        case "font.src":
          t.font.src = i.value;
          break;
        case "font.name":
          t.font.name = i.value;
          s = false;
          break;
        case "font.weight":
          t.font.weight = i.value;
          break;
        case "letterSpacing":
          t.letterSpacing = parseFloat(i.value);
          break;
        case "lineHeight":
          t.lineHeight = parseFloat(i.value);
          break;
        case "mergeGradients":
          t.mergeGradients = i.checked ? 1 : 0;
          break;
        case "rotate":
          t.rotate = parseFloat(i.value);
          break;
        case "align":
          t.align = i.value;
          break;
        case "lettering.active":
          t.lettering.active = i.checked ? 1 : 0;
          o._0x353fb5(t);
          break;
        case "lettering.reverseOverlap.letters":
          t.lettering.reverseOverlap.letters = i.checked ? 1 : 0;
          break;
        case "lettering.reverseOverlap.lines":
          t.lettering.reverseOverlap.lines = i.checked ? 1 : 0;
          break;
        case "lettering.boggle.active":
          t.lettering.boggle.active = i.checked ? 1 : 0;
          break;
        case "lettering.boggle.angle":
          t.lettering.boggle.angle = parseFloat(i.value);
          break;
        case "lettering.boggle.amplitude":
          t.lettering.boggle.amplitude = parseFloat(i.value);
          break;
        case "lettering.shadow.active":
          t.lettering.shadow.active = i.checked ? 1 : 0;
          break;
        case "lettering.shadow.size":
          t.lettering.shadow.size = parseFloat(i.value);
          break;
        case "lettering.shadow.distance":
          t.lettering.shadow.distance = parseFloat(i.value);
          break;
        case "lettering.shadow.angle":
          t.lettering.shadow.angle = parseFloat(i.value);
          break;
        case "lettering.shadow.mask":
          t.lettering.shadow.mask = i.checked ? 1 : 0;
          break;
        case "lettering.shadow.fill.alpha":
          t.lettering.shadow.fill.alpha = parseFloat(i.value);
          break;
        case "lettering.shadow.fill.color":
          l = TextEditorUtil.hexToRgb(i.value);
          t.lettering.shadow.fill.color.r = l.r;
          t.lettering.shadow.fill.color.g = l.g;
          t.lettering.shadow.fill.color.b = l.b;
          break;
        case "lettering.blendmode":
          t.lettering.blendmode = i.value;
          break;
        case "fill.active":
          t.fill.active = i.checked ? 1 : 0;
          break;
        case "fill.color":
          l = TextEditorUtil.hexToRgb(i.value);
          t.fill.color.r = l.r;
          t.fill.color.g = l.g;
          t.fill.color.b = l.b;
          break;
        case "fill.alpha":
          t.fill.alpha = parseFloat(i.value);
          break;
        case "fill.gradient.active":
          t.fill.gradient.active = i.checked ? 1 : 0;
          break;
        case "fill.gradient.angle":
          t.fill.gradient.angle = parseFloat(i.value);
          break;
        case "fill.gradient.colors":
          t.fill.gradient.colors = o._0x3c9c13(i.value);
          break;
        case "fill.palette.active":
          t.fill.palette.active = i.checked ? 1 : 0;
          break;
        case "fill.palette.lettering.method":
          t.fill.palette.lettering.method = i.value;
          break;
        case "fill.texture.active":
          t.fill.texture.active = i.checked ? 1 : 0;
          break;
        case "fill.texture.src":
          o._0x53f42b(i, "fill-texture", t, e => {
            a(t, s);
          });
          return;
        case "fill.texture.alpha":
          t.fill.texture.alpha = parseFloat(i.value);
          break;
        case "fill.texture.blendmode":
          t.fill.texture.blendmode = i.value;
          break;
        case "fill.texture.repeat":
          t.fill.texture.repeat = i.value;
          break;
        case "fill.texture.position":
          t.fill.texture.position = i.value;
          break;
        case "fill.texture.size":
          t.fill.texture.size = i.value;
          break;
        case "fill.texture.lettering":
          t.fill.texture.lettering = i.checked ? 1 : 0;
          break;
        case "outline.first.active":
          t.outline.first.active = i.checked ? 1 : 0;
          break;
        case "outline.first.width":
          t.outline.first.width = parseFloat(i.value);
          break;
        case "outline.first.fill.color":
          l = TextEditorUtil.hexToRgb(i.value);
          t.outline.first.fill.color.r = l.r;
          t.outline.first.fill.color.g = l.g;
          t.outline.first.fill.color.b = l.b;
          break;
        case "outline.first.dash":
          t.outline.first.dash = parseFloat(i.value);
          break;
        case "outline.first.join":
          t.outline.first.join = i.value;
          break;
        case "outline.first.fill.alpha":
          t.outline.first.fill.alpha = parseFloat(i.value);
          break;
        case "outline.first.fill.gradient.active":
          t.outline.first.fill.gradient.active = i.checked ? 1 : 0;
          break;
        case "outline.first.fill.gradient.colors":
          t.outline.first.fill.gradient.colors = o._0x3c9c13(i.value);
          break;
        case "outline.first.fill.gradient.angle":
          t.outline.first.fill.gradient.angle = parseFloat(i.value);
          break;
        case "outline.first.fill.texture.active":
          t.outline.first.fill.texture.active = i.checked ? 1 : 0;
          break;
        case "outline.first.fill.texture.src":
          o._0x53f42b(i, "outline-first-fill-texture", t, e => {
            a(t, s);
          });
          return;
        case "outline.first.fill.texture.alpha":
          t.outline.first.fill.texture.alpha = parseFloat(i.value);
          break;
        case "outline.first.fill.texture.blendmode":
          t.outline.first.fill.texture.blendmode = i.value;
          break;
        case "outline.first.fill.texture.repeat":
          t.outline.first.fill.texture.repeat = i.value;
          break;
        case "outline.first.fill.texture.position":
          t.outline.first.fill.texture.position = i.value;
          break;
        case "outline.first.fill.texture.size":
          t.outline.first.fill.texture.size = i.value;
          break;
        case "outline.first.fill.texture.lettering":
          t.outline.first.fill.texture.lettering = i.checked ? 1 : 0;
          break;
        case "outline.first.fill.palette.active":
          t.outline.first.fill.palette.active = i.checked ? 1 : 0;
          break;
        case "outline.first.fill.palette.lettering.method":
          t.outline.first.fill.palette.lettering.method = i.value;
          break;
        case "outline.second.active":
          t.outline.second.active = i.checked ? 1 : 0;
          break;
        case "outline.second.width":
          t.outline.second.width = parseFloat(i.value);
          break;
        case "outline.second.fill.color":
          l = TextEditorUtil.hexToRgb(i.value);
          t.outline.second.fill.color.r = l.r;
          t.outline.second.fill.color.g = l.g;
          t.outline.second.fill.color.b = l.b;
          break;
        case "outline.second.dash":
          t.outline.second.dash = parseFloat(i.value);
          break;
        case "outline.second.join":
          t.outline.second.join = i.value;
          break;
        case "outline.second.fill.alpha":
          t.outline.second.fill.alpha = parseFloat(i.value);
          break;
        case "outline.second.fill.gradient.active":
          t.outline.second.fill.gradient.active = i.checked ? 1 : 0;
          break;
        case "outline.second.fill.gradient.colors":
          t.outline.second.fill.gradient.colors = o._0x3c9c13(i.value);
          break;
        case "outline.second.fill.gradient.angle":
          t.outline.second.fill.gradient.angle = parseFloat(i.value);
          break;
        case "outline.second.fill.texture.active":
          t.outline.second.fill.texture.active = i.checked ? 1 : 0;
          break;
        case "outline.second.fill.texture.src":
          o._0x53f42b(i, "outline-second-fill-texture", t, e => {
            a(t, s);
          });
          return;
        case "outline.second.fill.texture.alpha":
          t.outline.second.fill.texture.alpha = parseFloat(i.value);
          break;
        case "outline.second.fill.texture.blendmode":
          t.outline.second.fill.texture.blendmode = i.value;
          break;
        case "outline.second.fill.texture.repeat":
          t.outline.second.fill.texture.repeat = i.value;
          break;
        case "outline.second.fill.texture.position":
          t.outline.second.fill.texture.position = i.value;
          break;
        case "outline.second.fill.texture.size":
          t.outline.second.fill.texture.size = i.value;
          break;
        case "outline.second.fill.texture.lettering":
          t.outline.second.fill.texture.lettering = i.checked ? 1 : 0;
          break;
        case "outline.second.fill.palette.active":
          t.outline.second.fill.palette.active = i.checked ? 1 : 0;
          break;
        case "outline.second.fill.palette.lettering.method":
          t.outline.second.fill.palette.lettering.method = i.value;
          break;
        case "outline.global.active":
          t.outline.global.active = i.checked ? 1 : 0;
          break;
        case "outline.global.width":
          t.outline.global.width = parseFloat(i.value);
          break;
        case "outline.global.fill.color":
          l = TextEditorUtil.hexToRgb(i.value);
          t.outline.global.fill.color.r = l.r;
          t.outline.global.fill.color.g = l.g;
          t.outline.global.fill.color.b = l.b;
          break;
        case "outline.global.join":
          t.outline.global.join = i.value;
          break;
        case "outline.global.fill.alpha":
          t.outline.global.fill.alpha = parseFloat(i.value);
          break;
        case "outline.global.fill.gradient.active":
          t.outline.global.fill.gradient.active = i.checked ? 1 : 0;
          break;
        case "outline.global.fill.gradient.colors":
          t.outline.global.fill.gradient.colors = o._0x3c9c13(i.value);
          break;
        case "outline.global.fill.gradient.angle":
          t.outline.global.fill.gradient.angle = parseFloat(i.value);
          break;
        case "outline.global.mask":
          t.outline.global.mask = i.checked ? 1 : 0;
          break;
        case "outline.global.projection":
          t.outline.global.projection = i.checked ? 1 : 0;
          break;
        case "outline.global.vector":
          t.outline.global.vector = i.checked ? 1 : 0;
          break;
        case "outline.global.shadow.active":
          t.outline.global.shadow.active = i.checked ? 1 : 0;
          break;
        case "outline.global.fill.texture.active":
          t.outline.global.fill.texture.active = i.checked ? 1 : 0;
          break;
        case "outline.global.fill.texture.src":
          o._0x53f42b(i, "outline-global-fill-texture", t, e => {
            a(t, s);
          });
          return;
        case "outline.global.fill.texture.alpha":
          t.outline.global.fill.texture.alpha = parseFloat(i.value);
          break;
        case "outline.global.fill.texture.blendmode":
          t.outline.global.fill.texture.blendmode = i.value;
          break;
        case "outline.global.fill.texture.repeat":
          t.outline.global.fill.texture.repeat = i.value;
          break;
        case "outline.global.fill.texture.position":
          t.outline.global.fill.texture.position = i.value;
          break;
        case "outline.global.fill.texture.size":
          t.outline.global.fill.texture.size = i.value;
          break;
        case "outline.global2.active":
          t.outline.global2.active = i.checked ? 1 : 0;
          break;
        case "outline.global2.width":
          t.outline.global2.width = parseFloat(i.value);
          break;
        case "outline.global2.fill.color":
          l = TextEditorUtil.hexToRgb(i.value);
          t.outline.global2.fill.color.r = l.r;
          t.outline.global2.fill.color.g = l.g;
          t.outline.global2.fill.color.b = l.b;
          break;
        case "outline.global2.join":
          t.outline.global2.join = i.value;
          break;
        case "outline.global2.fill.alpha":
          t.outline.global2.fill.alpha = parseFloat(i.value);
          break;
        case "outline.global2.fill.gradient.active":
          t.outline.global2.fill.gradient.active = i.checked ? 1 : 0;
          break;
        case "outline.global2.fill.gradient.colors":
          t.outline.global2.fill.gradient.colors = o._0x3c9c13(i.value);
          break;
        case "outline.global2.fill.gradient.angle":
          t.outline.global2.fill.gradient.angle = parseFloat(i.value);
          break;
        case "outline.global2.mask":
          t.outline.global2.mask = i.checked ? 1 : 0;
          break;
        case "outline.global2.projection":
          t.outline.global2.projection = i.checked ? 1 : 0;
          break;
        case "outline.global2.vector":
          t.outline.global2.vector = i.checked ? 1 : 0;
          break;
        case "outline.global2.shadow.active":
          t.outline.global2.shadow.active = i.checked ? 1 : 0;
          break;
        case "outline.global2.fill.texture.active":
          t.outline.global2.fill.texture.active = i.checked ? 1 : 0;
          break;
        case "outline.global2.fill.texture.src":
          o._0x53f42b(i, "outline-global2-fill-texture", t, e => {
            a(t, s);
          });
          return;
        case "outline.global2.fill.texture.alpha":
          t.outline.global2.fill.texture.alpha = parseFloat(i.value);
          break;
        case "outline.global2.fill.texture.blendmode":
          t.outline.global2.fill.texture.blendmode = i.value;
          break;
        case "outline.global2.fill.texture.repeat":
          t.outline.global2.fill.texture.repeat = i.value;
          break;
        case "outline.global2.fill.texture.position":
          t.outline.global2.fill.texture.position = i.value;
          break;
        case "outline.global2.fill.texture.size":
          t.outline.global2.fill.texture.size = i.value;
          break;
        case "distort.arc.angle":
          t.distort.arc.angle = parseFloat(i.value);
          o._0x54a16e(t, true);
          break;
        case "depth.active":
          t.depth.active = i.checked ? 1 : 0;
          break;
        case "depth.length":
          t.depth.length = parseFloat(i.value);
          break;
        case "depth.angle":
          t.depth.angle = parseFloat(i.value);
          break;
        case "depth.fill.color":
          l = TextEditorUtil.hexToRgb(i.value);
          t.depth.fill.color.r = l.r;
          t.depth.fill.color.g = l.g;
          t.depth.fill.color.b = l.b;
          break;
        case "depth.fill.alpha":
          t.depth.fill.alpha = parseFloat(i.value);
          break;
        case "depth.fill.mergeAlpha":
          t.depth.fill.mergeAlpha = parseFloat(i.value);
          break;
        case "depth.fill.gradient.active":
          t.depth.fill.gradient.active = i.checked ? 1 : 0;
          break;
        case "depth.fill.gradient.colors":
          t.depth.fill.gradient.colors = o._0x3c9c13(i.value);
          break;
        case "depth.fill.gradient.angle":
          t.depth.fill.gradient.angle = parseFloat(i.value);
          break;
        case "depth.fill.gradient.type":
          t.depth.fill.gradient.type = i.value;
          break;
        case "depth.fill.texture.active":
          t.depth.fill.texture.active = i.checked ? 1 : 0;
          break;
        case "depth.fill.texture.src":
          o._0x53f42b(i, "depth-fill-texture", t, e => {
            a(t, s);
          });
          return;
        case "depth.fill.texture.alpha":
          t.depth.fill.texture.alpha = parseFloat(i.value);
          break;
        case "depth.fill.texture.blendmode":
          t.depth.fill.texture.blendmode = i.value;
          break;
        case "depth.fill.texture.repeat":
          t.depth.fill.texture.repeat = i.value;
          break;
        case "depth.fill.texture.position":
          t.depth.fill.texture.position = i.value;
          break;
        case "depth.fill.texture.size":
          t.depth.fill.texture.size = i.value;
          break;
        case "depth2.active":
          t.depth2.active = i.checked ? 1 : 0;
          break;
        case "depth2.length":
          t.depth2.length = parseFloat(i.value);
          break;
        case "depth2.angle":
          t.depth2.angle = parseFloat(i.value);
          break;
        case "depth2.fill.color":
          l = TextEditorUtil.hexToRgb(i.value);
          t.depth2.fill.color.r = l.r;
          t.depth2.fill.color.g = l.g;
          t.depth2.fill.color.b = l.b;
          break;
        case "depth2.fill.alpha":
          t.depth2.fill.alpha = parseFloat(i.value);
          break;
        case "depth2.fill.mergeAlpha":
          t.depth2.fill.mergeAlpha = parseFloat(i.value);
          break;
        case "depth2.fill.gradient.active":
          t.depth2.fill.gradient.active = i.checked ? 1 : 0;
          break;
        case "depth2.fill.gradient.colors":
          t.depth2.fill.gradient.colors = o._0x3c9c13(i.value);
          break;
        case "depth2.fill.gradient.angle":
          t.depth2.fill.gradient.angle = parseFloat(i.value);
          break;
        case "depth2.fill.gradient.type":
          t.depth2.fill.gradient.type = i.value;
          break;
        case "depth2.fill.texture.active":
          t.depth2.fill.texture.active = i.checked ? 1 : 0;
          break;
        case "depth2.fill.texture.src":
          o._0x53f42b(i, "depth2-fill-texture", t, e => {
            a(t, s);
          });
          return;
        case "depth2.fill.texture.alpha":
          t.depth2.fill.texture.alpha = parseFloat(i.value);
          break;
        case "depth2.fill.texture.blendmode":
          t.depth2.fill.texture.blendmode = i.value;
          break;
        case "depth2.fill.texture.repeat":
          t.depth2.fill.texture.repeat = i.value;
          break;
        case "depth2.fill.texture.position":
          t.depth2.fill.texture.position = i.value;
          break;
        case "depth2.fill.texture.size":
          t.depth2.fill.texture.size = i.value;
          break;
        case "bevel.inner.active":
          t.bevel.inner.active = i.checked ? 1 : 0;
          break;
        case "bevel.inner.size":
          t.bevel.inner.size = parseFloat(i.value);
          break;
        case "bevel.inner.smoothing":
          t.bevel.inner.smoothing = i.checked ? 1 : 0;
          break;
        case "bevel.inner.soften":
          t.bevel.inner.soften = parseFloat(i.value);
          break;
        case "bevel.inner.angle":
          t.bevel.inner.angle = parseFloat(i.value);
          break;
        case "bevel.inner.highlight.alpha":
          t.bevel.inner.highlight.alpha = parseFloat(i.value);
          break;
        case "bevel.inner.highlight.color":
          l = TextEditorUtil.hexToRgb(i.value);
          t.bevel.inner.highlight.color.r = l.r;
          t.bevel.inner.highlight.color.g = l.g;
          t.bevel.inner.highlight.color.b = l.b;
          break;
        case "bevel.inner.highlight.blendmode":
          t.bevel.inner.highlight.blendmode = i.value;
          break;
        case "bevel.inner.shadow.alpha":
          t.bevel.inner.shadow.alpha = parseFloat(i.value);
          break;
        case "bevel.inner.shadow.color":
          l = TextEditorUtil.hexToRgb(i.value);
          t.bevel.inner.shadow.color.r = l.r;
          t.bevel.inner.shadow.color.g = l.g;
          t.bevel.inner.shadow.color.b = l.b;
          break;
        case "bevel.inner.shadow.blendmode":
          t.bevel.inner.shadow.blendmode = i.value;
          break;
        case "shadow.outer.active":
          t.shadow.outer.active = i.checked ? 1 : 0;
          break;
        case "shadow.outer.size":
          t.shadow.outer.size = parseFloat(i.value);
          break;
        case "shadow.outer.strength":
          t.shadow.outer.strength = parseFloat(i.value);
          break;
        case "shadow.outer.distance":
          t.shadow.outer.distance = parseFloat(i.value);
          break;
        case "shadow.outer.angle":
          t.shadow.outer.angle = parseFloat(i.value);
          break;
        case "shadow.outer.mask":
          t.shadow.outer.mask = i.checked ? 1 : 0;
          break;
        case "shadow.outer.fill.alpha":
          t.shadow.outer.fill.alpha = parseFloat(i.value);
          break;
        case "shadow.outer.fill.color":
          l = TextEditorUtil.hexToRgb(i.value);
          t.shadow.outer.fill.color.r = l.r;
          t.shadow.outer.fill.color.g = l.g;
          t.shadow.outer.fill.color.b = l.b;
          break;
        case "shadow.outer.fill.gradient.active":
          t.shadow.outer.fill.gradient.active = i.checked ? 1 : 0;
          break;
        case "shadow.outer.fill.gradient.colors":
          t.shadow.outer.fill.gradient.colors = o._0x3c9c13(i.value);
          break;
        case "shadow.outer.fill.gradient.angle":
          t.shadow.outer.fill.gradient.angle = parseFloat(i.value);
          break;
        case "shadow.outer2.active":
          t.shadow.outer2.active = i.checked ? 1 : 0;
          break;
        case "shadow.outer2.size":
          t.shadow.outer2.size = parseFloat(i.value);
          break;
        case "shadow.outer2.strength":
          t.shadow.outer2.strength = parseFloat(i.value);
          break;
        case "shadow.outer2.distance":
          t.shadow.outer2.distance = parseFloat(i.value);
          break;
        case "shadow.outer2.angle":
          t.shadow.outer2.angle = parseFloat(i.value);
          break;
        case "shadow.outer2.mask":
          t.shadow.outer2.mask = i.checked ? 1 : 0;
          break;
        case "shadow.outer2.fill.alpha":
          t.shadow.outer2.fill.alpha = parseFloat(i.value);
          break;
        case "shadow.outer2.fill.color":
          l = TextEditorUtil.hexToRgb(i.value);
          t.shadow.outer2.fill.color.r = l.r;
          t.shadow.outer2.fill.color.g = l.g;
          t.shadow.outer2.fill.color.b = l.b;
          break;
        case "shadow.outer2.fill.gradient.active":
          t.shadow.outer2.fill.gradient.active = i.checked ? 1 : 0;
          break;
        case "shadow.outer2.fill.gradient.colors":
          t.shadow.outer2.fill.gradient.colors = o._0x3c9c13(i.value);
          break;
        case "shadow.outer2.fill.gradient.angle":
          t.shadow.outer2.fill.gradient.angle = parseFloat(i.value);
          break;
        case "shadow.inner.active":
          t.shadow.inner.active = i.checked ? 1 : 0;
          break;
        case "shadow.inner.size":
          t.shadow.inner.size = parseFloat(i.value);
          break;
        case "shadow.inner.strength":
          t.shadow.inner.strength = parseFloat(i.value);
          break;
        case "shadow.inner.alpha":
          t.shadow.inner.alpha = parseFloat(i.value);
          break;
        case "shadow.inner.color":
          l = TextEditorUtil.hexToRgb(i.value);
          t.shadow.inner.color.r = l.r;
          t.shadow.inner.color.g = l.g;
          t.shadow.inner.color.b = l.b;
          break;
        case "shadow.inner.distance":
          t.shadow.inner.distance = parseFloat(i.value);
          break;
        case "shadow.inner.angle":
          t.shadow.inner.angle = parseFloat(i.value);
          break;
        case "shadow.inner.offset":
          t.shadow.inner.offset = parseFloat(i.value);
          break;
        case "shadow.inner.erosion.size":
          t.shadow.inner.erosion.size = parseFloat(i.value);
          break;
        case "shadow.inner.blendmode":
          t.shadow.inner.blendmode = i.value;
          break;
        case "shadow.inner2.active":
          t.shadow.inner2.active = i.checked ? 1 : 0;
          break;
        case "shadow.inner2.size":
          t.shadow.inner2.size = parseFloat(i.value);
          break;
        case "shadow.inner2.strength":
          t.shadow.inner2.strength = parseFloat(i.value);
          break;
        case "shadow.inner2.alpha":
          t.shadow.inner2.alpha = parseFloat(i.value);
          break;
        case "shadow.inner2.color":
          l = TextEditorUtil.hexToRgb(i.value);
          t.shadow.inner2.color.r = l.r;
          t.shadow.inner2.color.g = l.g;
          t.shadow.inner2.color.b = l.b;
          break;
        case "shadow.inner2.distance":
          t.shadow.inner2.distance = parseFloat(i.value);
          break;
        case "shadow.inner2.angle":
          t.shadow.inner2.angle = parseFloat(i.value);
          break;
        case "shadow.inner2.offset":
          t.shadow.inner2.offset = parseFloat(i.value);
          break;
        case "shadow.inner2.erosion.size":
          t.shadow.inner2.erosion.size = parseFloat(i.value);
          break;
        case "shadow.inner2.blendmode":
          t.shadow.inner2.blendmode = i.value;
          break;
        case "background.active":
          t.background.active = i.checked ? 1 : 0;
          o._0x3acc2a(t, true);
          s = false;
          break;
        case "background.fill.color":
          l = TextEditorUtil.hexToRgb(i.value);
          t.background.fill.color.r = l.r;
          t.background.fill.color.g = l.g;
          t.background.fill.color.b = l.b;
          o._0x3acc2a(t, o._0x18e0e7);
          s = false;
          break;
        case "background.fill.alpha":
          t.background.fill.alpha = parseFloat(i.value);
          o._0x3acc2a(t, true);
          s = false;
          break;
        case "background.fill.gradient.active":
          t.background.fill.gradient.active = i.checked ? 1 : 0;
          o._0x3acc2a(t, true);
          s = false;
          break;
        case "background.fill.gradient.colors":
          t.background.fill.gradient.colors = o._0x3c9c13(i.value);
          o._0x3acc2a(t, o._0x18e0e7);
          s = false;
          break;
        case "background.fill.gradient.angle":
          t.background.fill.gradient.angle = parseFloat(i.value);
          o._0x3acc2a(t, false);
          s = false;
          break;
        case "background.fill.gradient.type":
          t.background.fill.gradient.type = i.value;
          o._0x3acc2a(t, false);
          s = false;
          break;
        case "background.composite":
          t.background.composite = i.value;
          o._0x3acc2a(t, false);
          s = false;
          break;
        case "background.fill.image.active":
          t.background.fill.image.active = i.checked ? 1 : 0;
          o._0x51ac67(t);
          o._0x3acc2a(t, true);
          s = false;
          break;
        case "background.fill.image.src":
          const e = i;
          const n = e.files[0];
          const r = new FileReader();
          r.onload = async function (i) {
            e.value = "";
            t = await o._0x47141f(i.target.result, t);
            o._0x51ac67(t);
            o._0x3acc2a(t, true);
            s = false;
            a(t, s);
          };
          r.onerror = function (t) {
            e.value = "";
            alert(TextEditorUtil.getText("error-reading-image") + "\n" + r.error);
            r.abort();
          };
          r.readAsDataURL(n);
          return;
        case "background.fill.image.size":
          const d = isNaN(i.value) ? i.value : parseFloat(i.value);
          t.background.fill.image.size = d;
          o._0x3acc2a(t, false);
          s = false;
          break;
        case "background.fill.image.size.custom":
          s = false;
          break;
        case "background.fill.image.repeat":
          t.background.fill.image.repeat = i.value;
          o._0x3acc2a(t, false);
          s = false;
          break;
        case "background.fill.image.alpha":
          t.background.fill.image.alpha = parseFloat(i.value);
          o._0x3acc2a(t, true);
          s = false;
          break;
        case "icon.active":
          t.icon.active = i.checked ? 1 : 0;
          break;
        case "icon.src":
          const c = i;
          const u = c.files[0];
          const g = new FileReader();
          g.onload = async function (e) {
            c.value = "";
            t = await o._0x5440c3(e.target.result, t);
            o._0x8d94da(t);
            a(t, s);
          };
          g.onerror = function (t) {
            c.value = "";
            alert(TextEditorUtil.getText("error-reading-image") + "\n" + g.error);
            reader.abort();
          };
          g.readAsDataURL(u);
          return;
        case "icon.size":
          const h = isNaN(i.value) ? i.value : parseFloat(i.value);
          t.icon.size = h;
          break;
        case "icon.offset.x":
          t.icon.offset.x = parseFloat(i.value);
          break;
        case "icon.offset.y":
          t.icon.offset.y = parseFloat(i.value);
          break;
        case "icon.rotate":
          t.icon.rotate = parseFloat(i.value);
          break;
        case "icon.position":
          t.icon.position = i.value;
          o._0xd82f59(t);
          break;
        case "icon.composite":
          t.icon.composite = i.value;
          break;
        case "icon.alpha":
          t.icon.alpha = parseFloat(i.value);
          break;
        case "animation.active":
          t.animation.active = i.checked ? 1 : 0;
          o._0x319b75(t);
          s = false;
          break;
        case "animation.id":
          t.animation.id = i.value;
          o._0x319b75(t);
          s = false;
          break;
        case "animation.duration":
          t.animation.duration = parseFloat(i.value);
          o._0x319b75(t);
          s = false;
          break;
        case "animation.pause":
          t.animation.pause = parseFloat(i.value);
          o._0x319b75(t);
          s = false;
      }
      t = this._0x49ba7e(t, i);
      const r = e.startsWith("distort") || e.startsWith("font.src");
      const d = {};
      d.drawBevel = e.startsWith("bevel.inner") || r;
      d.drawDistort = e.startsWith("distort") || r;
      d.drawShadowErosion = e.startsWith("shadow.inner") || r;
      d.forceWaitDistortScript = d.drawDistort;
      d.isPostTreatment = r;
      a(t, s, d);
    },
    _0x49ba7e(t, e) {
      const i = t.lettering && t.lettering.active === 1 && t.lettering.boggle.active === 1;
      const n = getById("tt-background-fill-gradient-type-input");
      const a = getById("tt-background-fill-gradient-angle-option");
      if (n.value === "radial") {
        a.classList.add("tt-disabled");
      } else {
        a.classList.remove("tt-disabled");
      }
      const o = getById("tt-depth-angle-input");
      const l = getById("tt-depth2-angle-input");
      if (o.value !== l.value || t.depth.angle !== t.depth2.angle) {
        if (l === e) {
          o.value = l.value;
          t.depth.angle = t.depth2.angle;
        } else {
          l.value = o.value;
          t.depth2.angle = t.depth.angle;
        }
      }
      const s = getById("tt-outline-global-projection-option");
      if (t.depth.active === 1 && t.depth.length > 0) {
        s.classList.remove("tt-disabled");
      } else {
        s.classList.add("tt-disabled");
      }
      const r = getById("tt-outline-global2-projection-option");
      if (t.depth.active === 1 && t.depth.length > 0 || t.depth2.active === 1 && t.depth2.length > 0) {
        const e = getById("tt-outline-global2-projection-input");
        if (t.outline.global.active === 1 && t.outline.global.projection === 0 && t.depth.active === 1) {
          e.checked = false;
          t.outline.global2.projection = 0;
          r.classList.add("tt-disabled");
        } else {
          r.classList.remove("tt-disabled");
        }
      } else {
        r.classList.add("tt-disabled");
      }
      const d = getById("tt-merge-gradients-option");
      if (this.textEditor.texts && this.textEditor.texts.length > 1) {
        d.classList.remove("tt-disabled");
      } else {
        d.classList.add("tt-disabled");
      }
      const c = getById("tt-outline-global-join-option");
      if (t.outline.global.projection === 0 || i) {
        c.classList.add("tt-disabled");
      } else {
        c.classList.remove("tt-disabled");
      }
      const u = getById("tt-outline-global2-join-option");
      if (t.outline.global2.projection === 0 || i) {
        u.classList.add("tt-disabled");
      } else {
        u.classList.remove("tt-disabled");
      }
      getById("tt-depth-fill-gradient-angle-input").disabled = t.depth.fill.gradient.type === "depth";
      getById("tt-depth2-fill-gradient-angle-input").disabled = t.depth2.fill.gradient.type === "depth";
      const g = getById("tt-shadow-outer-mask-input");
      const h = getById("tt-shadow-outer2-mask-input");
      if (g.checked !== h.checked || t.shadow.outer.mask !== t.shadow.outer2.mask) {
        if (h === e) {
          g.checked = h.checked;
          t.shadow.outer.mask = t.shadow.outer2.mask;
        } else {
          h.value = g.value;
          t.shadow.outer2.mask = t.shadow.outer.mask;
        }
      }
      if (getById("tt-shadow-outer-mask-input").checked) {
        getById("tt-shadow-outer2-mask-input").checked = true;
      }
      return t;
    },
    _0x353fb5: function (t) {
      const e = t.lettering && t.lettering.active === 1;
      const i = window.pageYOffset;
      if (e) {
        this.tt.classList.add("tt-lettering");
      } else {
        this.tt.classList.remove("tt-lettering");
        if (this._0x3f6f4e) {
          for (const t of this._0x3f6f4e) {
            this._0x376bf6(t);
          }
        }
      }
      if (i !== window.pageYOffset) {
        window.scroll(0, i);
      }
    },
    _0x5434bc: function () {
      const t = this;
      const e = this.tt.querySelectorAll(".tt-palette button");
      for (const i of e) {
        i.addEventListener("click", function (e) {
          const i = e.target.closest(".tt-palette").getAttribute("data-palette");
          t._0x5ec186(i);
        });
      }
      const i = this.tt.querySelectorAll(".tt-backface-close");
      for (const e of i) {
        e.addEventListener("click", function (e) {
          const i = e.target.closest(".tt-column-inner").getAttribute("data-opened-palette");
          t._0x376bf6(i);
        });
      }
    },
    _0xe82854: function (t, e = null) {
      const i = this;
      const n = [];
      if (e) {
        const i = this.tt.querySelector(".tt-palette[data-palette=\"" + e + "\"]");
        const a = TextEditorUtil.pathResolve(e, t);
        n.push({
          id: e,
          node: i,
          config: a
        });
      } else {
        const i = this.tt.querySelectorAll(".tt-palette");
        for (const a of i) {
          e = a.getAttribute("data-palette");
          const i = TextEditorUtil.pathResolve(e, t);
          n.push({
            id: e,
            node: a,
            config: i
          });
        }
      }
      for (const t of n) {
        const e = t.node.querySelector("ul");
        e.innerHTML = "";
        if (t.config.styles && t.config.styles.length > 0) {
          let n = 0;
          for (const a of t.config.styles) {
            const t = document.createElement("li");
            if (a.solid) {
              const e = a.solid;
              t.style.backgroundColor = "rgb(" + e.r + "," + e.g + "," + e.b + ")";
            } else if (a.gradient) {
              const e = a.gradient.angle || 0;
              const i = a.gradient.colors;
              if (i.length > 1) {
                let n = "linear-gradient(" + (e * -1 + 90) + "deg ";
                for (const t of i) {
                  n += ", rgb(" + t.r + "," + t.g + "," + t.b + ") " + t.pos * 100 + "%";
                }
                n += ")";
                t.style.background = n;
              } else {
                const e = i[0];
                t.style.backgroundColor = "rgb(" + e.r + "," + e.g + "," + e.b + ")";
              }
            }
            t.addEventListener("click", function (t) {
              const e = t.target;
              const n = e.closest(".tt-palette").getAttribute("data-palette");
              const a = [...e.parentElement.children].indexOf(e);
              i._0x5ec186(n, a);
            });
            e.appendChild(t);
            n++;
          }
        }
        if (e.children.length > 0) {
          t.node.classList.add("tt-has-styles");
        } else {
          t.node.classList.remove("tt-has-styles");
        }
      }
    },
    _0x5ec186: function (t, e = null) {
      const i = this;
      if (this._0x3f6f4e) {
        for (const e of this._0x3f6f4e) {
          if (e !== t) {
            this._0x376bf6(e);
          }
        }
      }
      this._0x3f6f4e ||= [];
      this._0x3f6f4e.push(t);
      const n = this.tt.querySelector("[data-palette=\"" + t + "\"]");
      const a = n.closest(".tt-column-inner");
      a.setAttribute("data-opened-palette", t);
      a.classList.add("tt-show-backface");
      const o = a.querySelector(".tt-column-backface");
      let l = o.querySelector("[data-palette=\"" + t + "\"]");
      if (!l) {
        const e = getById("tt-palette-template");
        l = e.firstElementChild.cloneNode(true);
        l.setAttribute("data-palette", t);
        o.appendChild(l);
        l.querySelector(".tt-gradient-button").addEventListener("click", function (t) {
          const e = t.target.closest(".tt-palette-editor");
          const n = e.getAttribute("data-palette");
          const a = TextEditorUtil.pathResolve(n, i.textEditor.config);
          let o;
          if (a.styles.length > 0) {
            for (let t = a.styles.length - 1; t >= 0; t--) {
              const e = a.styles[t];
              if (e.gradient) {
                o = e;
                break;
              }
            }
          }
          o ||= {
            gradient: {
              angle: 90,
              colors: [{
                r: 0,
                g: 255,
                b: 255,
                pos: 0
              }, {
                r: 0,
                g: 0,
                b: 255,
                pos: 1
              }]
            }
          };
          i._0x3b2a85(e, o, true);
          i._0x526322(e);
        });
        l.querySelector(".tt-solid-button").addEventListener("click", function (t) {
          const e = t.target.closest(".tt-palette-editor");
          const n = e.getAttribute("data-palette");
          const a = TextEditorUtil.pathResolve(n, i.textEditor.config);
          let o;
          if (a.styles.length > 0) {
            for (let t = a.styles.length - 1; t >= 0; t--) {
              const e = a.styles[t];
              if (e.solid) {
                o = e;
                break;
              }
            }
          }
          o ||= {
            solid: {
              r: 255,
              g: 255,
              b: 255
            }
          };
          i._0x3b2a85(e, o, true);
          i._0x526322(e);
        });
        const a = l.querySelector(".tt-palette-styles");
        a._0x3cb901 = Sortable.create(a, {
          handle: ".tt-drag",
          animation: 150,
          onEnd: function (t) {
            t.item;
            i._0x1ea6f4(l);
            i._0x526322(l);
          }
        });
        l.querySelector(".tt-palette-title > span").innerHTML = n.getAttribute("data-title");
        i._0x4ae33b(l);
        this._0x2d5fb8 ||= [];
        this._0x2d5fb8.push(l);
      }
    },
    _0x376bf6: function (t) {
      const e = this.tt.querySelector("[data-palette=\"" + t + "\"]").closest(".tt-column-inner");
      e.removeAttribute("data-opened-palette");
      e.classList.remove("tt-show-backface");
      this._0xe82854(this.textEditor.config, t);
      const i = this._0x3f6f4e.indexOf(t);
      this._0x3f6f4e.splice(i, 1);
    },
    _0x552c0b: function () {
      if (this._0x2d5fb8) {
        for (const t of this._0x2d5fb8) {
          this._0x4ae33b(t);
        }
      }
    },
    _0x4ae33b: function (t) {
      const e = t.getAttribute("data-palette");
      t.querySelector(".tt-palette-styles").innerHTML = "";
      const i = TextEditorUtil.pathResolve(e, this.textEditor.config);
      if (i.styles && i.styles.length > 0) {
        for (const e of i.styles) {
          this._0x3b2a85(t, e, false);
        }
      }
    },
    _0x3b2a85: function (t, e, i) {
      const n = this;
      const a = t.querySelector(".tt-palette-styles");
      const o = document.createElement("div");
      const l = document.createElement("div");
      o.classList.add("tt-style-row");
      o.appendChild(l);
      a.appendChild(o);
      const s = document.createElement("div");
      s.classList.add("tt-position");
      const r = [...o.parentElement.children].indexOf(o);
      s.innerHTML = r + 1;
      l.appendChild(s);
      const d = document.createElement("div");
      d.classList.add("tt-drag");
      l.appendChild(d);
      if (e.solid) {
        o.classList.add("tt-solid-style");
        const i = e.solid;
        const a = document.createElement("div");
        a.classList.add("tt-color");
        l.appendChild(a);
        const s = TextEditorUtil.rgbToHex(i);
        a.style.background = s;
        a.setAttribute("data-color", s);
        a.addEventListener("click", e => {
          const i = e.target;
          const a = i.getAttribute("data-color");
          n._0x208c5f(a, i, null, (e, i, a, o) => {
            const l = i.toHEXA().toString();
            e.style.background = l;
            e.setAttribute("data-color", l);
            n._0x526322(t);
          });
        });
        o._0x4d9785 = a;
      } else if (e.gradient) {
        o.classList.add("tt-gradient-style");
        const i = document.createElement("div");
        i.classList.add("tt-gp");
        l.appendChild(i);
        const a = n._0x42b609(i);
        a.clear();
        e.gradient.angle;
        for (const t of e.gradient.colors) {
          a.addHandler(t.pos * 100, TextEditorUtil.rgbToHex(t));
        }
        for (const t of a.getHandlers()) {
          t.deselect();
        }
        a.on("handler:select", e => {
          const i = t.querySelector(".tt-palette-styles");
          for (const t of i.children) {
            if (t._0xe7cdcd && t._0xe7cdcd !== a) {
              for (const e of t._0xe7cdcd.getHandlers()) {
                e.deselect();
              }
            }
          }
        });
        a.on("change", e => {
          n._0x526322(t);
        });
        o._0xe7cdcd = a;
        const s = a.el.querySelector(".grp-wrapper");
        s._0xe7cdcd = a;
        s.id = "gp-" + TextEditorUtil.generateUUID();
        this._0x2da62e[s.id] = a;
        const r = document.createElement("div");
        r.classList.add("tt-angle");
        l.appendChild(r);
        const d = document.createElement("input");
        d.type = "range";
        d.min = "-180";
        d.max = "180";
        d.step = "2.5";
        d.value = e.gradient.angle;
        d.addEventListener("input", function (e) {
          n._0x526322(t);
        });
        r.appendChild(d);
        d.setAttribute("data-bubble", "V+\"\"");
        this._0x3a3054(d);
        o._0x451b6e = d;
        const c = document.createElement("div");
        c.title = " " + o._0x451b6e.value + " / " + TextEditorUtil.getText("gradient-angle-picker-label");
        const u = this._0xb38055();
        this._0x2dcc79(u, d.value);
        c.appendChild(u);
        c.classList.add("tt-angle-icon");
        c.addEventListener("click", function (t) {
          const e = this.closest(".tt-style-row");
          if (e.classList.contains("tt-show-angle")) {
            e.classList.remove("tt-show-angle");
            this.title = " " + e._0x451b6e.value + " / " + TextEditorUtil.getText("gradient-angle-picker-label");
            const t = this.querySelector("svg");
            n._0x2dcc79(t, e._0x451b6e.value);
          } else {
            e.classList.add("tt-show-angle");
            this.title = TextEditorUtil.getText("gradient-angle-picker-return");
          }
        });
        l.appendChild(c);
        o._0xe92f1f = u;
      }
      const c = document.createElement("div");
      c.classList.add("tt-trash");
      c.addEventListener("click", function (t) {
        const e = t.target.closest(".tt-palette-editor");
        const i = t.target.closest(".tt-style-row");
        const a = i.offsetHeight;
        i.style.marginTop = -a + "px";
        i.classList.add("tt-transition");
        i.classList.remove("tt-show");
        setTimeout(t => {
          i.remove();
          n._0x1ea6f4(e);
          n._0x526322(e);
        }, 100);
      });
      l.appendChild(c);
      const u = o.offsetHeight;
      let g;
      o.style.marginTop = -u + "px";
      o.parentNode.scrollTop = o.parentNode.scrollHeight;
      const h = t => {
        o.parentNode.scrollTop = o.parentNode.scrollHeight;
        g = setTimeout(h, 1);
      };
      setTimeout(t => {
        o.style.zIndex = -1;
        o.classList.add("tt-transition");
        o.classList.add("tt-show");
        o.style.marginTop = "0px";
        h();
        setTimeout(t => {
          o.parentNode.scrollTop = o.parentNode.scrollHeight;
          o.style.removeProperty("z-index");
          o.classList.remove("tt-transition");
          clearTimeout(g);
        }, 100);
      }, 15);
    },
    _0xb38055: function () {
      const t = getById("tt-angle-svg-template").firstElementChild.cloneNode(true);
      const e = TextEditorUtil.generateUUID();
      const i = t.querySelector("mask[id*=\"[GID]");
      i.id = i.id.replace(/\[GID\]/g, e);
      const n = t.querySelector("circle[mask]");
      const a = n.getAttribute("mask").replace(/\[GID\]/g, e);
      n.setAttribute("mask", a);
      return t;
    },
    _0x2dcc79: function (t, e) {
      const i = (e = e * -1 % 360) * Math.PI / 180;
      const n = 50 + Math.cos(i) * 34;
      const a = 50 + Math.sin(i) * 34;
      const o = t.querySelector("line");
      o.setAttribute("x2", n);
      o.setAttribute("y2", a);
    },
    _0x1ea6f4: function (t) {
      const e = t.querySelector(".tt-palette-styles");
      let i = 0;
      for (const t of e.children) {
        t.querySelector(".tt-position").innerHTML = i + 1;
        i++;
      }
    },
    _0x526322: function (t) {
      const e = t.querySelector(".tt-palette-styles");
      const i = t.getAttribute("data-palette");
      const n = TextEditorUtil.pathResolve(i, this.textEditor.config);
      const a = [];
      for (const t of e.children) {
        if (t._0xe7cdcd) {
          const e = t._0xe7cdcd.getColorValue();
          const i = TextEditorUtil.parseCssGradient(e);
          const n = [];
          for (const t of i) {
            const e = TextEditorUtil.hexToRgb(t.color);
            e.pos = t.pos / 100;
            n.push(e);
          }
          a.push({
            gradient: {
              angle: t._0x451b6e.value,
              colors: n
            }
          });
        } else if (t._0x4d9785) {
          const e = t._0x4d9785.getAttribute("data-color");
          const i = TextEditorUtil.hexToRgb(e);
          a.push({
            solid: i
          });
        }
      }
      n.styles = a;
      _drawManager(this.textEditor, this.textEditor.config, {
        isPostTreatment: false,
        drawBevel: false,
        drawDistort: false,
        drawShadowErosion: false
      });
    },
    _0x2f088a: function () {
      const t = this;
      const e = this.tt.querySelectorAll(".tt-texture-fieldset");
      for (const i of e) {
        i.querySelector(".tt-texture-delete-icon").addEventListener("click", function (e) {
          const i = e.target.closest("fieldset[data-texture-type]").getAttribute("data-texture-type");
          const n = i.replace(/-/g, ".");
          const a = TextEditorUtil.pathResolve(n, t.textEditor.config);
          a.src = null;
          t._0x214e3e(a, i);
          _drawManager(t.textEditor, t.textEditor.config, {
            isPostTreatment: true
          });
        });
      }
    },
    _0x214e3e: function (t, e) {
      const i = t && t.src;
      const n = this.tt.querySelector("[data-texture-type=\"" + e + "\"]");
      const a = n.querySelector(".tt-texture-label");
      const o = n.querySelector(".tt-texture-preview");
      const l = n.querySelector(".tt-texture-preview-image");
      const s = n.querySelector(".tt-texture-alpha-option");
      const r = n.querySelector(".tt-texture-lettering-option");
      if (i) {
        a.style.display = "none";
        o.style.display = "inline-flex";
        l.src = t.src;
        s.classList.remove("tt-disabled");
        n.classList.add("tt-has-content");
        if (r) {
          r.classList.remove("tt-disabled");
        }
      } else {
        a.style.display = "inline-flex";
        o.style.display = "none";
        l.removeAttribute("src");
        s.classList.add("tt-disabled");
        n.classList.remove("tt-has-content");
        if (r) {
          r.classList.add("tt-disabled");
        }
      }
    },
    _0x53f42b: async function (t, e, i, n) {
      const a = this;
      const o = 800;
      const l = e.replace(/-/g, ".");
      const s = TextEditorUtil.pathResolve(l, i);
      const r = t.files[0];
      const d = new FileReader();
      d.onload = async function (i) {
        t.value = "";
        let l = i.target.result;
        const r = TextEditorUtil.isSvgFromDataURL(l);
        a._0x386737(true, "custom");
        if (r && l.length * 0.66 / 1024 < 500) {
          let t;
          try {
            let e = TextEditorUtil.dataURLToSVGStr(l);
            e = TextEditorUtil.cleanSizeSvgStr(e);
            e = await TextEditorUtil.compressSVG(e);
            l = TextEditorUtil.SVGStrToDataURL(e);
            t = await TextEditorUtil.getImg(l);
          } catch (i) {
            console.log(i);
          }
          if (t) {
            s.active = 1;
            s.src = l;
            a._0x214e3e(s, e);
            if (n) {
              n();
            }
          } else {
            alert(TextEditorUtil.getText("error-reading-image"));
          }
        } else {
          if (r) {
            const t = new ResizeSVG();
            if (t.parse(l)) {
              let e;
              let i;
              if (t.width > t.height) {
                e = o;
                i = e / t.width * t.height;
              } else {
                i = o;
                e = i / t.height * t.width;
              }
              t.resize(e, i);
              l = t.getDataURL();
            } else {
              alert(TextEditorUtil.getText("error-reading-image"));
            }
          }
          const t = await TextEditorUtil.getImg(l);
          if (t) {
            const i = l.indexOf("data:image/jp") !== -1;
            let r;
            let d;
            if (TextEditorUtil.supportDataURLWebP()) {
              r = "image/webp";
              d = i ? 0.9 : 0.92;
            } else {
              r = i ? "image/jpeg" : "image/png";
              d = i ? 0.92 : null;
            }
            const c = TextEditorUtil.getScaleDownSize(t.naturalWidth, t.naturalHeight, o, o);
            const u = document.createElement("canvas");
            u.width = c.width;
            u.height = c.height;
            await TextEditorUtil.bestResize(t, u);
            s.active = 1;
            s.src = u.toDataURL(r, d);
            u.width = u.height = 0;
            a._0x214e3e(s, e);
            if (n) {
              n();
            }
          } else {
            alert(TextEditorUtil.getText("error-reading-image"));
          }
        }
        a._0x386737(false, "custom");
      };
      d.onerror = function (e) {
        t.value = "";
        alert(TextEditorUtil.getText("error-reading-image") + "\n" + d.error);
        d.abort();
      };
      d.readAsDataURL(r);
    },
    _0xefdd6d: function () {
      const t = this.tt.querySelectorAll("input[data-tt-checked-set]");
      for (let e = 0; e < t.length; e++) {
        t[e].addEventListener("input", function (t) {
          const e = getById(t.target.getAttribute("data-tt-input"));
          if (t.target.checked) {
            e.value = t.target.getAttribute("data-tt-checked-set");
          } else {
            e.value = t.target.getAttribute("data-tt-unchecked-set");
          }
          e.dispatchEvent(new Event("change"));
        });
      }
    },
    _0x30cc85: function () {
      const t = this.tt.querySelectorAll("input[data-tt-checked-set]");
      for (let e = 0; e < t.length; e++) {
        const i = t[e];
        if (getById(i.getAttribute("data-tt-input")).value === i.getAttribute("data-tt-checked-set")) {
          i.checked = true;
        } else {
          i.checked = false;
        }
      }
    },
    _0x5c108f: function (t) {
      const e = this.tt.querySelector("#tt-options section[data-name=\"custom\"]");
      if (e) {
        if (t.editable === 0) {
          e.classList.add("tt-uneditable");
        } else {
          e.classList.remove("tt-uneditable");
        }
      }
      const n = [{
        name: "fill",
        editable: t.fill.editable
      }, {
        name: "lettering",
        editable: t.lettering.editable
      }, {
        name: "depth",
        editable: t.depth.editable
      }, {
        name: "depth2",
        editable: t.depth2.editable
      }, {
        name: "outline-first",
        editable: t.outline.first.editable
      }, {
        name: "outline-second",
        editable: t.outline.second.editable
      }, {
        name: "outline-global",
        editable: t.outline.global.editable
      }, {
        name: "outline-global2",
        editable: t.outline.global2.editable
      }, {
        name: "bevel-inner",
        editable: t.bevel.inner.editable
      }, {
        name: "bevel-inner",
        editable: t.bevel.inner.editable
      }, {
        name: "shadow-inner",
        editable: t.shadow.inner.editable
      }, {
        name: "shadow-inner2",
        editable: t.shadow.inner2.editable
      }, {
        name: "shadow-outer",
        editable: t.shadow.outer.editable
      }, {
        name: "shadow-outer2",
        editable: t.shadow.outer2.editable
      }, {
        name: "shadow-outer-fill-gradient",
        editable: t.shadow.outer.fill.gradient.editable
      }, {
        name: "shadow-outer2-fill-gradient",
        editable: t.shadow.outer2.fill.gradient.editable
      }];
      for (i in n) {
        const t = n[i];
        const e = this.tt.querySelector("fieldset#tt-" + t.name + "-fieldset");
        if (e) {
          if (t.editable === 0) {
            e.classList.add("tt-uneditable");
          } else {
            e.classList.remove("tt-uneditable");
          }
        }
      }
    },
    _0x2255f0: function (t) {
      return t.processing?.alphabet?.glyphs?.length > 0;
    },
    _0x511624: function (t) {
      t.hideControls ||= [];
      const e = this._0x2255f0(t);
      const i = t.hideControls.includes("font.weight") || e;
      const n = t.hideControls.includes("mergeGradients") || e;
      const a = t.hideControls.includes("shadow.outer.mask") || e;
      const o = t.hideControls.includes("shadow.outer2.mask") || e;
      const l = this.tt.querySelector(".tt-font-options-list li[data-input*=\"weight\"]");
      if (l) {
        l.style.display = i ? "none" : "flex";
      }
      const s = this.tt.querySelector("#tt-merge-gradients-option");
      if (s) {
        s.style.display = n ? "none" : "block";
      }
      const r = this.tt.querySelector("#tt-shadow-outer-mask-option");
      if (r) {
        r.style.display = a ? "none" : "block";
      }
      const d = this.tt.querySelector("#tt-shadow-outer2-mask-option");
      if (d) {
        d.style.display = o ? "none" : "block";
      }
    },
    _0x17c1b8: function () {
      const t = this;
      setTimeout(function () {
        const e = document.querySelector("#tt-options > section[data-name=\"custom\"]").querySelectorAll("input, select");
        function i(n) {
          for (let t = 0; t < e.length; t++) {
            e[t].removeEventListener("change", i);
          }
          t.preventConfigHasChanged = true;
        }
        for (let t = 0; t < e.length; t++) {
          e[t].addEventListener("change", i);
        }
      }, 2000);
      window.addEventListener("beforeunload", e => {
        if (t.preventConfigHasChanged) {
          e.preventDefault();
          e.returnValue = "";
          return "";
        }
      });
    },
    _0x37276a: function () {
      const t = this;
      const e = getById("tt-options-menu").getElementsByTagName("li");
      for (let i = 0; i < e.length; i++) {
        e[i].addEventListener("click", function (e) {
          t._0x498dac(this.getAttribute("data-name"));
        });
      }
      t._0x498dac(t._0x2d0da5());
    },
    _0x498dac: function (t) {
      const e = this;
      const i = function (t, e) {
        getById("tt-options").querySelector("section[data-name=\"" + t + "\"]").style.display = e ? "flex" : "none";
      };
      const n = getById("tt-options-menu");
      const a = n.getElementsByTagName("li");
      const o = window.pageYOffset;
      const l = n.querySelector("[data-name=\"" + t + "\"]");
      l.classList.add("selected");
      i(t, true);
      for (let t = 0; t < a.length; t++) {
        if (l !== a[t]) {
          a[t].classList.remove("selected");
          i(a[t].getAttribute("data-name"), false);
        }
      }
      if (o !== window.pageYOffset) {
        window.scroll(0, o);
      }
      setTimeout(function () {
        e._0xf5b7cf();
      }, 1);
      n.dispatchEvent(new CustomEvent("displayed", {
        detail: {
          name: t
        },
        bubbles: true,
        cancelable: true,
        composed: false
      }));
    },
    _0x2d0da5: function () {
      return getById("tt-options-menu").getElementsByClassName("selected")[0].getAttribute("data-name");
    },
    _0x5a3a27: function () {
      const t = this;
      const e = getById("tt-custom-menu");
      const i = e.getElementsByTagName("li");
      const n = function (e) {
        const n = function (t, e) {
          const i = getById("tt-options").querySelectorAll("[data-custom^=\"" + t + "\"]");
          for (let t = 0; t < i.length; t++) {
            i[t].style.display = e ? "flex" : "none";
          }
        };
        const a = window.pageYOffset;
        e.classList.add("selected");
        n(e.getAttribute("data-filter"), true);
        for (let t = 0; t < i.length; t++) {
          if (e !== i[t]) {
            i[t].classList.remove("selected");
            n(i[t].getAttribute("data-filter"), false);
          }
        }
        if (a !== window.pageYOffset) {
          window.scroll(0, a);
        }
        t._0xf5b7cf();
      };
      for (let t = 0; t < i.length; t++) {
        i[t].addEventListener("click", function (t) {
          n(this);
        });
      }
      n(e.getElementsByClassName("selected")[0]);
    },
    _0x5ff4f5: function () {
      const t = this;
      window.addEventListener("scroll", function (e) {
        t._0x768578();
      });
    },
    _0x768578: function () {
      const t = getById("tt-canvas-wrapper");
      const e = this.tt.getBoundingClientRect().top + window.scrollY;
      let i = 300;
      if (window.scrollY > e) {
        const t = Math.abs(window.scrollY - e);
        i = Math.max(100, 300 - t);
      }
      t.style.height = i + "px";
      t.style.marginBottom = 300 - i + "px";
      if (i <= 100) {
        t.classList.add("tt-canvas-sticky");
      } else {
        t.classList.remove("tt-canvas-sticky");
      }
    },
    _0xd05976: function () {
      const t = this;
      getById("tt-canvas-center").addEventListener("click", function (e) {
        const i = t._0x2d0da5();
        t._0x498dac(i === "save" ? "text" : "save");
      });
    },
    _0x289fb3: function (t) {
      const e = t.split(",\n");
      let i;
      let n = [];
      for (let t = 0; t < e.length; t++) {
        i = e[t].split(" ");
        n.push({
          color: i[0],
          position: i[1]
        });
      }
      return n;
    },
    _0x3c9c13: function (t) {
      let e = [];
      if (t.trim() !== "") {
        let i;
        let n;
        let a = t.split(",").map(t => t.trim()).filter(t => t.length > 0);
        for (let t = 0; t < a.length; t++) {
          i = a[t].trim().replace(/\s+/, " ").split(" ");
          if (i.length === 2) {
            n = parseFloat(i[1].trim()) / 100;
            i = TextEditorUtil.hexToRgb(i[0].trim());
            i.pos = isNaN(n) ? 0 : n;
            e.push(i);
          }
        }
      }
      return e;
    },
    _0x3ddf75: function (t, e) {
      t.clear();
      for (let i = 0; i < e.length; i++) {
        col = e[i];
        if (col) {
          col.r = col.r ? col.r : 0;
          col.g = col.g ? col.g : 0;
          col.b = col.b ? col.b : 0;
          col.a = col.a !== undefined ? col.a : 1;
          col.pos = col.pos ? col.pos : 0;
          t.addHandler(col.pos * 100, TextEditorUtil.rgbToHex(col));
        }
      }
    },
    _0x189438: function (t) {
      t = t.toString();
      if (/rgb/.test(t)) {
        const e = t.replace(/^rgba?\(|\s+|\)$/g, "").split(",");
        const i = {
          r: e[0],
          g: e[1],
          b: e[2]
        };
        for (let [t, e] of Object.entries(i)) {
          i[t] = parseInt(e);
        }
        if (e.length > 3) {
          i.a = parseFloat(e[3]);
        }
        t = TextEditorUtil.rgbToHex(i);
      }
      return t;
    },
    _0x196421() {
      const t = this;
      const e = this.tt.querySelectorAll("input.tt-color");
      for (const i of e) {
        const e = document.createElement("button");
        e.classList.add("tt-pickr-button");
        e.setAttribute("data-update-color-input", i.id);
        i.type = "text";
        i.style.display = "none";
        i.parentNode.insertBefore(e, i.nextSibling);
        e.addEventListener("click", e => {
          const i = e.target.getAttribute("data-update-color-input");
          const n = t.tt.querySelector("#" + i);
          const a = n.value;
          const o = {};
          o.opacity = n.getAttribute("data-opacity") === "1";
          t._0x208c5f(a, e.target, o, (e, i, a, o) => {
            const l = i.toHEXA().toString();
            n.value = l;
            t._0x43351(n);
            n.dispatchEvent(new Event("input"));
          }, t => n.dispatchEvent(new Event("change")));
        });
      }
    },
    _0x43351(t) {
      inputs = t ? [t] : this.tt.querySelectorAll("input.tt-color");
      for (const t of inputs) {
        if (!t) {
          continue;
        }
        t.style.background = t.value;
        const e = t.parentNode.querySelector(".tt-pickr-button");
        if (e) {
          e.style.setProperty("--color", t.value);
        }
      }
    },
    _0x535934() {
      let t = [];
      (function e(i) {
        for (const n in i) {
          if (i[n] && i[n].r !== undefined) {
            const e = TextEditorUtil.rgbToHex(i[n]);
            t.push(e);
          } else if (typeof i[n] == "object") {
            e(i[n]);
          }
        }
      })(this.textEditor.config);
      for (const e in t) {
        const i = t[e];
        if (/^#(\w+){6}ff$/i.test(i)) {
          t[e] = i.substr(0, i.length - 2);
        }
      }
      t = t.filter(t => ["#ffffff", "#000000"].indexOf(t.toLowerCase()) === -1);
      t = [...new Set(t)];
      if (t > this._0x22016f) {
        const e = t.length - this._0x22016f;
        t.splice(-e);
      }
      this._0x545d7b = t;
    },
    _0x22016f: 14,
    _0x208c5f: function (t, e, i, n, a) {
      const o = this;
      if (this._0x5d7de1) {
        if (this._0x5d7de1.isOpen()) {
          this._0x5d7de1.hide();
          return;
        }
        this._0x5d7de1 = null;
      }
      const l = e.getBoundingClientRect();
      const s = l.top > window.innerHeight - l.top ? "top" : "bottom";
      const r = this._0x545d7b ? this._0x545d7b : [];
      const d = {
        default: t,
        el: e,
        theme: "nano",
        position: s + "-start",
        autoReposition: true,
        useAsButton: true,
        swatches: r,
        closeWithKey: "Escape",
        padding: 3,
        components: {
          preview: true,
          opacity: !i || (i.opacity, false) || i.opacity,
          hue: true,
          interaction: {
            hex: false,
            rgba: false,
            hsla: false,
            hsva: false,
            cmyk: false,
            input: true,
            clear: false,
            save: false
          }
        }
      };
      o._0x5d7de1 = Pickr.create(d).on("show", (t, e) => {
        o._0x125793 = null;
        o._0x482e5e = t.toHEXA().toString();
      }).on("hide", t => {
        if (o._0x125793 && o._0x125793 !== "swatch") {
          o._0x545d7b ||= [];
          const e = t.getColor().toHEXA().toString();
          o._0x545d7b = [e].concat(o._0x545d7b);
          o._0x545d7b = [...new Set(o._0x545d7b)];
          if (o._0x545d7b.length > o._0x22016f) {
            const t = o._0x545d7b.length - o._0x22016f;
            o._0x545d7b.splice(-t);
          }
        }
        const e = t.getColor();
        if (a && o._0x482e5e !== e.toHEXA().toString()) {
          a(e);
        }
        t.destroyAndRemove();
        o._0x5d7de1 = null;
      }).on("change", (t, i, a) => {
        o._0x125793 = i;
        if (n) {
          n(e, t, i, a);
        }
      }).show();
      return o._0x5d7de1;
    },
    _0x42b609: function (t, e) {
      const i = this;
      const n = "gp-" + TextEditorUtil.generateUUID();
      const a = new Grapick({
        el: t,
        colorEl: "<div class=\"tt-pickr-gradient-button\" data-id=\"" + n + "\"></div>"
      });
      a.setColorPicker(t => {
        const e = t.getEl().querySelector(".tt-pickr-gradient-button");
        if (e) {
          e.addEventListener("click", e => {
            const n = i._0x189438(t.getColor());
            i._0x208c5f(n, e.target, null, (t, e, n, a) => {
              const o = a.options.el.getAttribute("data-id");
              const l = i._0x2da62e[o];
              l.el.querySelector(".grp-preview");
              const s = l.el.querySelector(".grp-handler-selected");
              let r = 0;
              const d = l.getHandlers();
              for (const t of d) {
                if (t.el === s) {
                  break;
                }
                r++;
              }
              l.getHandler(r).setColor(e.toHEXA(), 1);
              i._0x2621f7(l);
            });
          });
        }
      });
      a.on("handler:add", t => {
        i._0x2621f7(a);
      });
      const o = a.el.querySelector(".grp-wrapper");
      o.id = n;
      this._0x2da62e[o.id] = a;
      if (e) {
        o.setAttribute("data-tt-option", e);
        a.on("change", t => {
          const e = a.el.getAttribute("data-update-input");
          const n = document.getElementById(e);
          const o = a.getColorValue();
          const l = TextEditorUtil.parseCssGradient(o);
          n.value = "";
          l.forEach(function (t) {
            if (t) {
              if (n.value != "") {
                n.value += ",\n";
              }
              n.value += t.color + " " + t.pos + "%";
            }
          });
          if (!i._0x18e0e7) {
            n.dispatchEvent(new Event("change"));
          }
        });
      }
      return a;
    },
    _0x2621f7(t) {
      const e = t.getHandlers();
      for (const t of e) {
        const e = t.el.querySelector(".tt-pickr-gradient-button");
        if (!e) {
          return;
        }
        const i = this._0x189438(t.getColor());
        e.style.setProperty("--color", i);
      }
    },
    _0x2da62e: [],
    _0x18e0e7: false,
    _0x59c30f: function (t) {
      const e = this;
      const i = this.tt.getElementsByClassName("tt-gradient-picker");
      for (const t of i) {
        const e = t.getAttribute("data-update-input");
        const i = document.getElementById(e).getAttribute("data-tt-option");
        this._0x42b609(t, i);
      }
      document.addEventListener("contextmenu", t => {
        const i = t.target.className;
        if (typeof i != "string" || !i.startsWith("grp")) {
          return;
        }
        t.preventDefault();
        t.stopPropagation();
        const n = t.target.closest(".grp-wrapper");
        if (!n) {
          return;
        }
        const a = e._0x2da62e[n.id];
        const o = a.getColorValue();
        const l = TextEditorUtil.parseCssGradient(o);
        const s = l.length;
        if (s < 2) {
          return;
        }
        let r = 0;
        for (const t of l) {
          const t = r * (1 / (s - 1));
          a.getHandler(r).setPosition(t * 100);
          r++;
        }
      });
      document.addEventListener("mousedown", t => {
        if (t.which !== 2) {
          return;
        }
        const i = t.target.className;
        if (typeof i != "string" || !i.startsWith("grp")) {
          return;
        }
        t.preventDefault();
        t.stopPropagation();
        const n = t.target.closest(".grp-wrapper");
        if (!n) {
          return;
        }
        const a = e._0x2da62e[n.id];
        const o = a.getColorValue();
        const l = TextEditorUtil.parseCssGradient(o);
        if (l.length < 1) {
          return;
        }
        let s = [];
        const r = a.getHandlers();
        for (const t of r) {
          s.push({
            position: t.getPosition(),
            isSelected: t.isSelected()
          });
        }
        a.clear();
        let d = 0;
        for (const t of l) {
          const e = 100 - s[d].position;
          a.addHandler(e, t.color, s[d].isSelected);
          d++;
        }
      });
    },
    _0x488aa7: function (t, e) {
      let i = [];
      if (e) {
        for (const t in this._0x2da62e) {
          const n = getById(t);
          if (!n) {
            continue;
          }
          const a = n.getAttribute("data-tt-option");
          if (!a) {
            continue;
          }
          const o = e.getAttribute("data-tt-option");
          if (o && a === o) {
            i[t] = this._0x2da62e[t];
            break;
          }
        }
      } else {
        i = this._0x2da62e;
      }
      for (const e in i) {
        const n = getById(e);
        if (!n) {
          continue;
        }
        const a = i[e];
        const o = n.getAttribute("data-tt-option");
        if (!o) {
          continue;
        }
        const l = TextEditorUtil.pathResolve(o, t);
        this._0x18e0e7 = true;
        this._0x3ddf75(a, l);
        this._0x18e0e7 = false;
        this._0x2621f7(a);
      }
    },
    _0x25aaae: function () {
      const t = this;
      function e() {
        const t = getById("tt-bevel-inner-active-text");
        const e = t.getAttribute("data-load-text");
        t.setAttribute("data-load-text", t.innerHTML);
        t.innerHTML = e;
      }
      this.textEditor.on("startLoadOpencv", function () {
        e();
      });
      this.textEditor.on("opencvLoaded", function (i) {
        e();
        if (!t.textEditor.drawConfig.forceWaitOpenCV) {
          _drawManager(t.textEditor, t.textEditor.config, {
            isPostTreatment: true
          });
        }
      });
    },
    _0x2f5e77: function () {
      const t = this;
      this.textEditor.on("startLoadDistortScript", function () {
        t._0x386737(true, "text");
      });
      this.textEditor.on("distortScriptLoaded", function () {
        t._0x386737(false, "text");
        if (!t.textEditor.drawConfig.forceWaitDistortScript) {
          _drawManager(t.textEditor, t.textEditor.config, {
            isPostTreatment: true
          });
        }
      });
      this.textEditor.on("startApplyDistort", function () {
        t._0x386737(true, "*");
      });
      this.textEditor.on("applyDistortFinish", function () {
        t._0x386737(false, "*");
      });
    },
    _0x54a16e: function (t, e) {},
    _0x59527b: function () {
      let t = this;
      const e = getById("tt-import-preset-input");
      if (e) {
        e.addEventListener("change", function (e) {
          let i = e.target;
          let n = i.files[0];
          let a = new FileReader();
          a.onload = async function (e) {
            i.value = "";
            try {
              const i = e.target.result;
              let n = JSON.parse(i);
              t.alreadyDrawn = false;
              const a = {
                forceWaitOpenCV: true,
                forceWaitDistortScript: true,
                isPostTreatment: true
              };
              const o = t.textEditor.setConfig(n);
              _drawManager(t.textEditor, o, a);
              t._0x2ca34f(o);
            } catch (e) {
              alert(TextEditorUtil.getText("error-decoding-preset-config-file"));
              return false;
            }
          };
          a.readAsText(n);
        });
      }
    },
    _0x1cc384: {},
    _0x5732e0: {},
    _0x43ea09: {},
    _0x25fad6: {},
    _0x473f29: function () {
      const t = this;
      const e = this.tt.querySelectorAll("[data-undo-control]");
      for (let i = 0; i < e.length; i++) {
        const n = e[i];
        const a = n.getAttribute("data-undo-control");
        if (!getById(a)) {
          continue;
        }
        const o = t._0x1cc384[a] !== undefined && t._0x1cc384[a].length > 1 ? "inline-flex" : "none";
        n.style.display = o;
      }
    },
    _0x409566: function () {
      const t = this;
      const e = this.tt.querySelectorAll("[data-undo-control]");
      for (let i = 0; i < e.length; i++) {
        const n = e[i];
        const a = n.getAttribute("data-undo-control");
        const o = getById(a);
        if (o) {
          n.addEventListener("click", function (e) {
            t._0x18e0e7 = t._0x554869 = true;
            const i = e.target.getAttribute("data-undo-control");
            const n = getById(i);
            const a = t._0x1cc384[i][t._0x1cc384[i].length - 2];
            t._0x1cc384[i].pop();
            if (n.type === "checkbox") {
              n.checked = a;
            } else {
              n.value = a;
            }
            let o = t._0x5a762e(i);
            n.dispatchEvent(new Event(o.events[0]));
            if (i.indexOf("-color-") !== -1) {
              t._0x43351(n);
            }
            if (i.indexOf("-gradient-") !== -1) {
              t._0x488aa7(t.textEditor.config, n);
            }
            t._0x473f29();
            setTimeout(e => {
              t._0x18e0e7 = t._0x554869 = false;
            }, 100);
          });
          if (o.type === "hidden") {
            const e = new MutationObserver(e => {
              if (t._0x554869) {
                return;
              }
              const i = e[0].target;
              const n = i.id;
              if (t._0x25fad6[n]) {
                clearTimeout(t._0x25fad6[n]);
              }
              t._0x25fad6[n] = setTimeout(e => {
                t._0xe9dd09(i);
              }, 400);
            });
            e.observe(o, {
              attributes: true
            });
          } else {
            o.addEventListener("change", function (e) {
              t._0xe9dd09(e.target);
            });
          }
        }
      }
    },
    _0xe9dd09: function (t) {
      const e = this;
      if (e._0x554869) {
        return;
      }
      const i = t.id;
      if (!e._0x5732e0[i]) {
        e._0x2ac0ca(t);
        e._0x5732e0[i] = true;
        e._0x473f29();
      }
      if (e._0x43ea09[i]) {
        clearTimeout(e._0x43ea09[i]);
      }
      e._0x43ea09[i] = setTimeout(t => {
        e._0x5732e0[i] = false;
        e._0x473f29();
      }, 1000);
    },
    _0x5a762e: function (t) {
      for (let e = 0; e < this._0x2a246e.length; e++) {
        if (this._0x2a246e[e].id === t) {
          return this._0x2a246e[e];
        }
      }
      return false;
    },
    _0x2fa414: function () {
      const t = this;
      const e = this.tt;
      t._0x1cc384 = {};
      const i = e.querySelectorAll("[data-undo-control]");
      for (let e = 0; e < i.length; e++) {
        const n = i[e].getAttribute("data-undo-control");
        const a = getById(n);
        if (a) {
          t._0x2ac0ca(a);
        }
      }
    },
    _0x2ac0ca: function (t) {
      const e = this;
      const i = t.id;
      let n = t.type === "checkbox" ? t.checked : t.value;
      if (e._0x1cc384[i] === undefined) {
        e._0x1cc384[i] = [];
      }
      const a = e._0x1cc384[i].length;
      if (a > 0) {
        let o = e._0x1cc384[i][a - 1];
        if (t.type === "checkbox" && o === t.checked) {
          return;
        }
        if (t.id.indexOf("gradient-colors") !== -1) {
          n = TextEditorUtil.removeAllHexOpaqueAlpha(n);
          o = TextEditorUtil.removeAllHexOpaqueAlpha(o);
        }
        if (o === n) {
          return;
        }
      }
      e._0x1cc384[i].push(n);
    },
    _0x33a77f: ["over", "mask", "lighter", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"],
    _0x54f474: ["repeat", "no-repeat"],
    _0x5bd3ff: ["left top", "center top", "right top", "left center", "center", "right center", "left bottom", "center bottom", "right bottom"],
    _0x28cfc4: ["stretch", "stretch-x", "stretch-y", "1", "0.9", "0.8", "0.7", "0.6", "0.5", "0.4", "0.3", "0.2", "0.1"],
    _0x597ee2: function () {
      const t = [{
        selector: ".tt-blendmode-select",
        data: this._0x33a77f
      }, {
        selector: ".tt-texture-repeat-select",
        data: this._0x54f474
      }, {
        selector: ".tt-texture-position-select",
        data: this._0x5bd3ff
      }, {
        selector: ".tt-texture-size-select",
        data: this._0x28cfc4
      }];
      for (const e of t) {
        const t = this.tt.querySelectorAll(e.selector);
        for (const i of t) {
          const t = document.createElement("optgroup");
          t.label = i.title;
          i.add(t);
          for (const i of e.data) {
            const e = document.createElement("option");
            e.value = i;
            e.text = parseFloat(i) == i ? parseFloat(i) * 100 + "%" : i;
            t.appendChild(e);
          }
          i.selectedIndex = 0;
        }
      }
    },
    _0x115fb4: function () {
      if (isChrome()) {
        return;
      }
      const t = this.tt.querySelectorAll("[data-only-chrome]");
      for (const e of t) {
        e.style.display = "none";
      }
    },
    _0x280c28: function () {
      const t = this;
      if (this._0x4d1282()) {
        return;
      }
      let e = this.tt.querySelectorAll("input[data-only-premium]");
      for (const i of e) {
        i.disabled = true;
        i.parentNode.addEventListener("click", function (e) {
          t._0x5a772c(true);
        });
      }
      e = this.tt.querySelectorAll("label.tt-premium");
      for (const i of e) {
        i.addEventListener("click", function (e) {
          t._0x5a772c(true);
        });
      }
    },
    _0x5458f5: function () {
      const t = this;
      const e = this.tt.querySelectorAll("[data-active-fieldset]");
      for (const i of e) {
        i.addEventListener("change", function (e) {
          if (t._0x725344(e)) {
            t._0x5050df(e.target);
          }
        });
      }
      const i = e => {
        const i = e.parentNode.querySelectorAll("li");
        const n = window.pageYOffset;
        for (const t of i) {
          getById(t.getAttribute("data-show")).style.display = t === e ? "" : "none";
          if (t === e) {
            t.classList.add("selected");
          } else {
            t.classList.remove("selected");
          }
        }
        t._0x2a9467(e);
        if (n !== window.pageYOffset) {
          window.scroll(0, n);
        }
      };
      const n = this.tt.querySelectorAll(".tt-show-brother li");
      for (const t of n) {
        t.addEventListener("click", function (t) {
          i(t.target);
        });
        if (t.classList.contains("selected")) {
          i(t);
        }
      }
    },
    _0x725344: function (t) {
      const e = t.target;
      if (!e.checked) {
        return true;
      }
      if (e.id.indexOf("palette-active") !== -1) {
        const i = e.closest(".tt-column").querySelector("input[id*=\"gradient-active\"]");
        if (i && i.checked) {
          t.stopImmediatePropagation();
          i.checked = false;
          const n = i.getAttribute("data-tt-option").split(".").slice(0, -1).join(".");
          TextEditorUtil.pathResolve(n, this.textEditor.config).active = 0;
          e.dispatchEvent(new Event("change"));
          this._0x5050df(i);
          return false;
        }
      } else if (e.id.indexOf("gradient-active") !== -1) {
        const i = e.closest(".tt-column").querySelector("input[id*=\"palette-active\"]");
        if (i && i.checked) {
          t.stopImmediatePropagation();
          i.checked = false;
          const n = i.getAttribute("data-tt-option").split(".").slice(0, -1).join(".");
          TextEditorUtil.pathResolve(n, this.textEditor.config).active = 0;
          e.dispatchEvent(new Event("change"));
          this._0x5050df(i);
          return false;
        }
      }
      return true;
    },
    _0x2a9467: function (t) {
      let e;
      e = t ? [t] : this.tt.querySelectorAll(".tt-show-brother li");
      for (const t of e) {
        const e = t.parentNode.querySelectorAll("li");
        for (const t of e) {
          const e = getById(t.getAttribute("data-show")).querySelector("legend input[id*=\"active\"]");
          if (e) {
            if (e.checked) {
              t.classList.add("tt-content-actived");
            } else {
              t.classList.remove("tt-content-actived");
            }
          }
        }
      }
    },
    _0x5050df: function (t) {
      const e = window.pageYOffset;
      const i = t ? [t] : this.tt.querySelectorAll("[data-active-fieldset]");
      for (let t = 0; t < i.length; t++) {
        const e = i[t];
        const n = e.checked;
        const a = e.getAttribute("data-active-fieldset") + "-fieldset";
        const o = getById(a);
        const l = n ? "remove" : "add";
        o.classList[l]("tt-col-disabled");
        if (o.getAttribute("data-autominimize") === "1") {
          if (n) {
            o.classList.remove("tt-minimized");
          } else {
            o.classList.add("tt-minimized");
          }
        }
      }
      if (e !== window.pageYOffset) {
        window.scroll(0, e);
      }
      setTimeout(t => {
        this._0xf5b7cf();
      }, 1);
    },
    _0x3a1eb0: function () {
      const t = this;
      getById("tt-icon-preview-delete-icon").addEventListener("click", function (e) {
        const i = t.textEditor.config;
        i.icon.src = null;
        t._0x8d94da(i);
        t._0x5a7856(i);
        _drawManager(t.textEditor, i, {
          isPostTreatment: true
        });
      });
      getById("tt-icon-import-label").addEventListener("click", function (e) {
        if (!t._0x4d1282()) {
          e.stopPropagation();
          e.preventDefault();
          t._0x5a772c(true);
        }
      });
      const e = this.tt;
      const i = getById("tt-options-menu");
      t._0x30b704 = 1;
      t._0x543e27 = e.querySelector("#tt-icon-list ul");
      t._0x24b6a9 = e.querySelector("#tt-icon-search-input");
      t._0xce87e2 = e.querySelector("#tt-icon-list-loading");
      t._0xcd8c35 = e.querySelector("#tt-icon-list-no-result");
      t._0x24b6a9.addEventListener("input", function (e) {
        if (t._0x30ca76) {
          clearTimeout(t._0x30ca76);
        }
        t._0x30ca76 = setTimeout(function () {
          t._0x30b704 = 1;
          t._0x26c0a4(false);
        }, 500);
      });
      t._0x543e27.addEventListener("scroll", function (e) {
        const i = e.target;
        if (i.scrollHeight - i.clientHeight - i.scrollTop < 200 && !t._0x48077a && t._0x30b704 !== -1 && (t._0x234bfc || t._0x30b704 < 1)) {
          t._0x30b704++;
          t._0x26c0a4(false);
        }
      });
      i.addEventListener("displayed", function e(i) {
        if (i.detail.name === "icon") {
          i.target.removeEventListener("displayed", e);
          t._0x26c0a4(true);
        }
      });
      this.tt.querySelector("#tt-undo-svg-colors").addEventListener("click", function (e) {
        if (!t._0x3bf6b0 || t._0x3bf6b0.length === 0) {
          return;
        }
        const i = t._0x3bf6b0.pop();
        i.input.setAttribute("data-previous-color", i.color);
        i.input.value = i.color;
        t._0x18e0e7 = true;
        i.input.dispatchEvent(new Event("input"));
        t._0x18e0e7 = false;
        t._0x128e76();
      });
    },
    _0x26c0a4: async function (t) {
      const e = this;
      e._0x48077a = true;
      let i = "ajax/icons?getIcons=1";
      if (t) {
        i += "&getCats=1";
      }
      if (e._0x3b9011 !== undefined) {
        i += "&catId=" + e._0x3b9011;
      }
      if (e._0x24b6a9.value.trim() !== "") {
        i += "&search=" + e._0x24b6a9.value.trim();
      }
      i += "&page=" + e._0x30b704;
      e._0xce87e2.style.display = "block";
      e._0xcd8c35.style.display = "none";
      const n = await TextEditorUtil.fetch(url(i), "json", true);
      e._0x48077a = false;
      e._0xce87e2.style.display = "none";
      if (!n) {
        return false;
      }
      e._0x234bfc = !!n.hasMoreResults;
      if (n.icons !== undefined) {
        e._0x54b13b(n.icons);
        if (n.icons.length === 0) {
          e._0xcd8c35.style.display = "block";
          e._0x30b704 = -1;
        }
      }
      n.cats;
      n.catId;
    },
    _0x54b13b: function (t) {
      const e = this;
      if (e._0x30b704 === 1) {
        e._0x543e27.innerHTML = "";
      }
      const i = t => {
        e._0x386737(false, "icon");
        alert(TextEditorUtil.getText("error-reading-image"));
      };
      for (let n = 0; n < t.length; n++) {
        const a = document.createElement("li");
        const o = new Image();
        o.src = t[n].previewFile;
        a.appendChild(o);
        a.setAttribute("data-id", t[n].id);
        a.setAttribute("data-file", t[n].file);
        a.title = t[n].name;
        a.addEventListener("click", async function (t) {
          const n = t.target;
          e._0x386737(true, "icon");
          const a = n.getAttribute("data-id");
          const o = n.getAttribute("data-file");
          const l = await TextEditorUtil.fetch(o, "blob", true);
          if (!l) {
            i();
            return;
          }
          const s = await TextEditorUtil.fileReader(l, "readAsDataURL", true);
          if (!s) {
            i();
            return;
          }
          let r = e.textEditor.config;
          r = await e._0x5440c3(s, r);
          e._0x8d94da(r);
          _drawManager(e.textEditor, r, {
            isPostTreatment: true
          });
          e._0x386737(false, "icon");
          const d = url("ajax/icons?setCounter=1&iconId=" + a);
          TextEditorUtil.fetch(d, "json", true);
        });
        e._0x543e27.append(a);
      }
      if (this._0x30b704 === 1) {
        e._0x543e27.scrollTo(0, 0);
      }
    },
    _0x5440c3: async function (t, e) {
      const i = this;
      this._0x386737(true, "icon");
      let n = false;
      const a = TextEditorUtil.isSvgFromDataURL(t);
      let o = !e.icon.src;
      if (a && t.length * 0.66 / 1024 < 500) {
        let a;
        try {
          let e = TextEditorUtil.dataURLToSVGStr(t);
          e = TextEditorUtil.cleanSizeSvgStr(e);
          e = await TextEditorUtil.compressSVG(e);
          t = TextEditorUtil.SVGStrToDataURL(e);
          a = await TextEditorUtil.getImg(t);
        } catch (t) {
          console.log(t);
        }
        if (a) {
          e.icon.active = 1;
          e.icon.src = t;
          await i._0x5a7856(e);
          n = true;
        } else {
          alert(TextEditorUtil.getText("error-reading-image"));
        }
      } else if (t !== null) {
        if (a) {
          const e = new ResizeSVG();
          if (e.parse(t)) {
            const i = 800;
            const n = e.height / e.width * i;
            e.resize(i, n);
            t = e.getDataURL();
          } else {
            alert(TextEditorUtil.getText("error-reading-image"));
          }
        }
        const i = await TextEditorUtil.getImg(t);
        if (i) {
          const t = TextEditorUtil.getScaleDownSize(i.naturalWidth, i.naturalHeight, 800, 800);
          const n = document.createElement("canvas");
          n.width = t.width;
          n.height = t.height;
          await TextEditorUtil.bestResize(i, n);
          e.icon.active = 1;
          e.icon.src = n.toDataURL("image/webp", 1);
          n.width = n.height = 0;
        } else {
          alert(TextEditorUtil.getText("error-reading-image"));
        }
      } else {
        e.icon.active = 0;
        e.icon.src = null;
      }
      if (!n) {
        await i._0x5a7856(e);
      }
      if (o && e.icon.src) {
        i._0xd82f59(e);
      }
      this._0x386737(false, "icon");
      return e;
    },
    _0x386737(t, e) {
      const i = e !== "*" ? "=\"" + e + "\"" : "";
      const n = tt.querySelectorAll("#tt-options > section[data-name" + i + "]");
      for (const e of n) {
        if (t) {
          e.classList.add("tt-loading");
          const t = document.activeElement;
          if (t && t.tagName === "INPUT" && !t.disabled) {
            t.disabled = true;
            setTimeout(e => t.disabled = false, 1);
          }
        } else {
          e.classList.remove("tt-loading");
        }
      }
    },
    _0x5a7856: async function (t) {
      const e = this;
      const i = this.tt.querySelector("#tt-icon-svg-colors");
      const n = i.querySelector("ul");
      let a = false;
      if (TextEditorUtil.isSvgFromDataURL(t.icon.src)) {
        e._0x386737(true, "icon");
        e._0x112a7e = new ReplaceSVGColors();
        let o = [];
        try {
          o = await e._0x112a7e.parseColors(t.icon.src);
        } catch (t) {
          console.log(t);
        }
        e._0x3bf6b0 = [];
        n.innerHTML = "";
        const l = o.length;
        if (l > 0 && l < 10) {
          a = true;
          for (let i = 0; i < o.length; i++) {
            const a = o[i].current;
            const l = document.createElement("input");
            l.type = "color";
            l.value = a;
            l.setAttribute("data-previous-color", a);
            l.setAttribute("data-id", i);
            l.classList.add("tt-svg-color-input");
            const s = document.createElement("li");
            s.appendChild(l);
            n.appendChild(s);
            l.addEventListener("input", function (i) {
              const n = i.target;
              const a = parseInt(n.getAttribute("data-id"));
              const o = e._0x112a7e.colors[a];
              o.previous = o.current;
              o.current = n.value;
              e._0x112a7e.replaceColors([o]);
              (t = e.textEditor.config).icon.src = e._0x112a7e.getDataURL();
              _drawManager(e.textEditor, t, {
                isPostTreatment: false,
                drawBevel: false,
                drawDistort: false,
                drawShadowErosion: false
              });
            });
            l.addEventListener("change", function (t) {
              const i = t.target;
              const n = i.getAttribute("data-previous-color");
              i.setAttribute("data-previous-color", i.value);
              e._0x3bf6b0.push({
                input: i,
                color: n
              });
              e._0x128e76();
            });
          }
          i.style.display = "flex";
        }
        e._0x128e76();
        e._0x386737(false, "icon");
      }
      if (!a) {
        n.innerHTML = "";
        i.style.display = "none";
      }
      return t;
    },
    _0x128e76: function () {
      this.tt.querySelector("#tt-undo-svg-colors").style.display = this._0x3bf6b0 && this._0x3bf6b0.length > 0 ? "inline-flex" : "none";
    },
    _0x8d94da: function (t) {
      const e = !!t.icon.src;
      const i = getById("tt-icon-import-label");
      const n = getById("tt-icon-preview-container");
      const a = getById("tt-icon-preview-img");
      i.style.display = e ? "none" : "inline-flex";
      n.style.display = e ? "inline-flex" : "none";
      if (e) {
        a.src = t.icon.src;
      }
      const o = getById("tt-icon-size-option");
      const l = getById("tt-icon-offset-x-option");
      const s = getById("tt-icon-offset-y-option");
      const r = getById("tt-icon-position-option");
      const d = getById("tt-icon-order-option");
      const c = getById("tt-icon-alpha-option");
      const u = getById("tt-icon-rotate-option");
      if (e) {
        o.classList.remove("tt-disabled");
        l.classList.remove("tt-disabled");
        s.classList.remove("tt-disabled");
        r.classList.remove("tt-disabled");
        d.classList.remove("tt-disabled");
        c.classList.remove("tt-disabled");
        u.classList.remove("tt-disabled");
      } else {
        o.classList.add("tt-disabled");
        l.classList.add("tt-disabled");
        s.classList.add("tt-disabled");
        r.classList.add("tt-disabled");
        d.classList.add("tt-disabled");
        c.classList.add("tt-disabled");
        u.classList.add("tt-disabled");
      }
      getById("tt-icon-active-input").checked = t.icon.active === 1;
      this._0x5050df();
    },
    _0xd82f59: function (t) {
      const e = this;
      if (t.icon.position === "left" || t.icon.position === "right") {
        t.icon.offset.x = 0.05;
        t.icon.offset.y = 0;
        e._0x8d94da(t);
      } else if (t.icon.position === "top" || t.icon.position === "bottom") {
        t.icon.offset.y = 0.05;
        t.icon.offset.x = 0;
        e._0x8d94da(t);
      } else {
        t.icon.offset.y = 0;
        t.icon.offset.x = 0;
        e._0x8d94da(t);
      }
      getById("tt-icon-offset-x-input").value = t.icon.offset.x;
      getById("tt-icon-offset-y-input").value = t.icon.offset.y;
    },
    _0x4593c1: function () {
      const t = this;
      getById("tt-background-fill-image-import-label").addEventListener("click", function (e) {
        if (!t._0x4d1282()) {
          e.stopPropagation();
          e.preventDefault();
          t._0x5a772c(true);
        }
      });
      getById("tt-background-fill-image-preview-delete-icon").addEventListener("click", function (e) {
        t.textEditor.config.background.fill.image.src = null;
        t._0x51ac67(t.textEditor.config);
        t._0x3acc2a(t.textEditor.config, true);
      });
      getById("tt-background-fill-image-size-type-input").addEventListener("input", function (e) {
        const i = getById("tt-background-fill-image-size-custom-input");
        const n = this.value === "custom" ? i.value : this.value;
        const a = t.textEditor.config;
        a.background.fill.image.size = n;
        t._0x51ac67(a);
        t._0x3acc2a(a, false);
      });
      const e = getById("tt-background-fill-image-size-custom-input");
      e.addEventListener("input", function (e) {
        t.textEditor.config.background.fill.image.size = this.value;
        t._0x3acc2a(t.textEditor.config, false);
        const i = getById("tt-main-container");
        if (!t._0x18e0e7) {
          i.style.opacity = 0.5;
        }
      });
      e.addEventListener("change", function (t) {
        getById("tt-main-container").style.opacity = 1;
      });
      const i = getById("tt-background-save-preset-icon");
      if (i) {
        i.addEventListener("click", function (e) {
          let i = JSON.stringify(t.textEditor.config.background.fill, null, 2);
          let n = t._0x2d899d("background-preset", "json");
          TextEditorUtil.download(i, n, "text/plain");
        });
      }
      if (getById("tt-background-import-preset-icon")) {
        getById("tt-background-import-preset-input").addEventListener("change", function (e) {
          const i = e.target;
          const n = i.files[0];
          const a = new FileReader();
          a.onload = e => {
            i.value = "";
            try {
              const i = JSON.parse(e.target.result);
              const n = t.textEditor.config;
              n.background.active = 1;
              n.background.fill = TextEditorUtil.mergeDeep(n.background.fill, i);
              t.textEditor.config = n;
              t._0x51ac67(n);
              t._0x3acc2a(n, true);
              t._0xf5b7cf();
            } catch (e) {
              alert(TextEditorUtil.getText("error-decoding-bg-preset-file"));
              return false;
            }
          };
          a.readAsText(n);
        });
      }
      const n = getById("tt-background-export-preset-icon");
      if (n) {
        n.addEventListener("click", function (e) {
          const i = JSON.stringify(t.textEditor.config.background.fill, null, 2);
          const a = n.getAttribute("data-url");
          const o = document.createElement("form");
          o.target = "_blank";
          o.method = "POST";
          o.action = a;
          o.style.display = "none";
          const l = document.createElement("input");
          l.type = "hidden";
          l.name = "data";
          l.value = i;
          o.appendChild(l);
          document.body.appendChild(o);
          o.submit();
          document.body.removeChild(o);
        });
      }
      window.addEventListener("resize", function () {
        t._0xf5b7cf();
      });
      window.addEventListener("orientationchange", function () {
        t._0xf5b7cf();
      });
      const a = this.tt;
      const o = getById("tt-options-menu");
      t._0x3bdf10 = 1;
      t._0x55e857 = a.querySelector("#tt-background-list ul");
      t._0x17db96 = a.querySelector("#tt-background-search-input");
      t._0x4d4fac = a.querySelector("#tt-background-list-loading");
      t._0x26ffb8 = a.querySelector("#tt-background-list-no-result");
      t._0x17db96.addEventListener("input", function (e) {
        if (t._0x4791ec) {
          clearTimeout(t._0x4791ec);
        }
        t._0x4791ec = setTimeout(function () {
          t._0x3bdf10 = 1;
          t._0x176dad(false);
        }, 500);
      });
      t._0x55e857.addEventListener("scroll", function (e) {
        const i = e.target;
        if (i.scrollHeight - i.clientHeight - i.scrollTop < 200 && !t._0x2156b7 && t._0x3bdf10 !== -1 && (t._0x69f41a || t._0x3bdf10 < 1)) {
          t._0x3bdf10++;
          t._0x176dad(false);
        }
      });
      o.addEventListener("displayed", function e(i) {
        if (i.detail.name === "background") {
          i.target.removeEventListener("displayed", e);
          t._0x176dad(true);
        }
      });
    },
    _0x176dad: async function (t) {
      const e = this;
      e._0x2156b7 = true;
      let i = "ajax/backgrounds?getBackgrounds=1";
      if (t) {
        i += "&getCats=1";
      }
      if (e._0x463351 !== undefined) {
        i += "&catId=" + e._0x463351;
      }
      if (e._0x17db96.value.trim() !== "") {
        i += "&search=" + e._0x17db96.value.trim();
      }
      i += "&page=" + e._0x3bdf10;
      e._0x4d4fac.style.display = "block";
      e._0x26ffb8.style.display = "none";
      const n = await TextEditorUtil.fetch(url(i), "json", true);
      e._0x2156b7 = false;
      e._0x4d4fac.style.display = "none";
      if (!n) {
        return false;
      }
      e._0x69f41a = !!n.hasMoreResults;
      if (n.backgrounds !== undefined) {
        e._0x47363e(n.backgrounds);
        if (n.backgrounds.length === 0) {
          e._0x26ffb8.style.display = "block";
          e._0x3bdf10 = -1;
        }
      }
      n.cats;
      n.catId;
    },
    _0x47363e: function (t) {
      const e = this;
      if (e._0x3bdf10 === 1) {
        e._0x55e857.innerHTML = "";
      }
      const i = getById("tt-background-list").querySelector("ul");
      for (let n = 0; n < t.length; n++) {
        const a = e.textEditor.config;
        const o = t[n];
        const l = document.createElement("li");
        l.title = o.name + (o.image_format ? " " + o.image_format.toUpperCase() : "");
        l.setAttribute("data-id", o.id);
        l.setAttribute("data-preset", o.file);
        l.setAttribute("data-premium", o.premium);
        const s = document.createElement("div");
        s.style.backgroundImage = "url(" + o.preview + ")";
        l.appendChild(s);
        i.append(l);
        l.addEventListener("click", async function (t) {
          e._0x386737(true, "background");
          const i = this.getAttribute("data-id");
          const n = this.getAttribute("data-preset");
          if (n.endsWith(".json")) {
            const t = await TextEditorUtil.fetch(n, "json", true);
            if (!t) {
              e._0x386737(false, "background");
              alert(TextEditorUtil.getText("error-loading-background"));
              return;
            }
            const i = TextEditorUtil.cloneObject(a.background);
            if (!t.image.src) {
              i.fill.image.active = 0;
            }
            a.background.active = 1;
            a.background.fill = TextEditorUtil.mergeDeep(a.background.fill, t);
            if (!t.image.src) {
              a.background.fill.image = TextEditorUtil.mergeDeep(a.background.fill.image, i.fill.image);
            }
          } else {
            await TextEditorUtil.fetch(n, "blob", true);
            a.background.active = 1;
            a.background.fill.color = {
              r: 0,
              g: 0,
              b: 0
            };
            a.background.fill.image.active = 1;
            a.background.fill.image.alpha = 1;
            a.background.fill.image.src = n;
            a.background.fill.image.size = "cover";
            a.background.fill.gradient.active = 0;
          }
          e.textEditor.config = a;
          e._0x51ac67(a);
          e._0x3acc2a(a, true);
          e._0xf5b7cf();
          const o = e.tt.querySelectorAll("#tt-options > section[data-name=\"background\"] [data-tt-option]");
          for (const t of o) {
            e._0x2ac0ca(t);
          }
          e._0x386737(false, "background");
          if (i) {
            const t = url("ajax/backgrounds?setCounter=1&backgroundId=" + i);
            TextEditorUtil.fetch(t, "json", true);
          }
        });
      }
      if (this._0x3bdf10 === 1) {
        e._0x55e857.scrollTo(0, 0);
      }
    },
    _0x47141f: async function (t, e) {
      const i = !!getById("tt-background-fill-image-raster-max-size-input")?.checked;
      const n = i ? 4096 : 1280;
      const a = i ? 4096 : 1024;
      const o = TextEditorUtil.isSvgFromDataURL(t);
      this._0x386737(true, "background");
      if (o && t.length * 0.66 / 1024 < a) {
        let i;
        try {
          let e = TextEditorUtil.dataURLToSVGStr(t);
          e = TextEditorUtil.cleanSizeSvgStr(e);
          e = await TextEditorUtil.compressSVG(e, ["removeRasterImages"]);
          t = TextEditorUtil.SVGStrToDataURL(e);
          i = await TextEditorUtil.getImg(t);
        } catch (t) {
          console.log(t);
        }
        if (i) {
          e.background.fill.image.active = 1;
          e.background.fill.image.src = t;
        } else {
          alert(TextEditorUtil.getText("error-reading-image"));
        }
      } else if (t !== null) {
        if (o) {
          const e = new ResizeSVG();
          if (e.parse(t)) {
            const i = n;
            const a = e.height / e.width * i;
            e.resize(i, a);
            t = e.getDataURL();
          } else {
            alert(TextEditorUtil.getText("error-reading-image"));
          }
        }
        const i = await TextEditorUtil.getImg(t);
        if (i) {
          const a = t.indexOf("data:image/jp") !== -1;
          let o;
          let l;
          if (TextEditorUtil.supportDataURLWebP()) {
            o = "image/webp";
            l = a ? 0.9 : 1;
          } else {
            o = a ? "image/jpeg" : "image/png";
            l = a ? 0.92 : null;
          }
          const s = TextEditorUtil.getScaleDownSize(i.naturalWidth, i.naturalHeight, n, n);
          const r = document.createElement("canvas");
          r.width = s.width;
          r.height = s.height;
          await TextEditorUtil.bestResize(i, r);
          e.background.fill.image.active = 1;
          e.background.fill.image.src = r.toDataURL(o, l);
          r.width = r.height = 0;
        } else {
          alert(TextEditorUtil.getText("error-reading-image"));
        }
      } else {
        e.background.fill.image.active = 0;
        e.background.fill.image.src = null;
      }
      this._0x386737(false, "background");
      return e;
    },
    _0x51ac67: function (t) {
      const e = this;
      const i = getById("tt-background-active-input");
      const n = getById("tt-background-fill-color-input");
      const a = getById("tt-background-fill-alpha-input");
      const o = getById("tt-background-fill-gradient-active-input");
      const l = getById("tt-background-fill-gradient-type-input");
      const s = getById("tt-background-fill-gradient-colors-input");
      const r = getById("tt-background-fill-gradient-angle-input");
      n.value = t.background.fill.color ? TextEditorUtil.rgbToHex(t.background.fill.color) : "#000000";
      i.checked = t.background.active === 1;
      a.value = t.background.fill.alpha;
      o.checked = t.background.fill.gradient.active === 1;
      l.value = t.background.fill.gradient.type;
      r.value = t.background.fill.gradient.angle;
      let d = "";
      t.background.fill.gradient.colors.forEach(function (t) {
        if (d != "") {
          d += ",\n";
        }
        const e = TextEditorUtil.rgbToHex(t);
        t.pos;
        d += e + " " + t.pos + "%";
      });
      s.value = d;
      e._0x488aa7(t, s);
      const c = e._0x5a762e(n.id);
      n.dispatchEvent(new Event(c.events[0]));
      e._0x43351(n);
      const u = t.background.fill && t.background.fill.image && t.background.fill.image.src;
      const g = getById("tt-background-fill-image-import-label");
      const h = getById("tt-background-fill-image-preview-container");
      const p = getById("tt-background-fill-image-preview-img");
      g.style.display = u ? "none" : "inline-flex";
      h.style.display = u ? "inline-flex" : "none";
      if (u) {
        p.src = TextEditorUtil.normalizeImageSrc(t.background.fill.image.src);
      }
      const f = getById("tt-background-fill-image-active-input");
      const b = getById("tt-background-fill-image-size-input");
      const m = getById("tt-background-fill-image-size-type-input");
      const v = getById("tt-background-fill-image-size-custom-input");
      const w = getById("tt-background-fill-image-repeat-input");
      const k = getById("tt-background-fill-image-alpha-input");
      f.checked = t.background.fill.image.active === 1;
      const x = t.background.fill.image.size;
      b.value = x;
      m.value = isNaN(x) ? x : "custom";
      if (!isNaN(x)) {
        v.value = x;
      }
      w.value = t.background.fill.image.repeat;
      k.value = t.background.fill.image.alpha;
      const y = getById("tt-background-fill-image-size-type-option");
      const _0x4f07d8 = getById("tt-background-fill-image-size-custom-option");
      const E = getById("tt-background-fill-image-repeat-option");
      const L = getById("tt-background-fill-image-alpha-option");
      if (u) {
        y.classList.remove("tt-disabled");
      } else {
        y.classList.add("tt-disabled");
      }
      if (u && m.value === "custom") {
        _0x4f07d8.classList.remove("tt-disabled");
      } else {
        _0x4f07d8.classList.add("tt-disabled");
      }
      if (u && m.value !== "cover" && m.value !== "stretch") {
        E.classList.remove("tt-disabled");
      } else {
        E.classList.add("tt-disabled");
      }
      if (u) {
        L.classList.remove("tt-disabled");
      } else {
        L.classList.add("tt-disabled");
      }
      e._0x5050df();
    },
    _0x3acc2a: function (t, e) {
      const i = getById("tt-background");
      const n = i.querySelector(".tt-background-color");
      const a = i.querySelector(".tt-background-image");
      const o = this.tt.querySelector("#tt-canvas-wrapper");
      const l = t.background;
      if (l.active !== 1) {
        i.style.opacity = 0;
        return;
      }
      i.style.opacity = 1;
      let s = "";
      if (l.fill.gradient.active === 1 && l.fill.gradient.colors && l.fill.gradient.colors.length > 0) {
        const t = l.fill.gradient.angle;
        const e = l.fill.gradient.colors;
        if (e.length > 1) {
          let i;
          i = TextEditorUtil.pathResolve("fill.gradient.type", l) === "radial" ? "radial-gradient(ellipse at center " : "linear-gradient(" + (t * -1 + 90) + "deg ";
          for (let t = 0; t < e.length; t++) {
            const n = e[t];
            const a = n.a !== undefined ? n.a : 1;
            i += ", rgba(" + n.r + "," + n.g + "," + n.b + "," + a + ") " + n.pos * 100 + "%";
          }
          i += ")";
          s = i;
        } else {
          const t = e[0];
          const i = t.a !== undefined ? t.a : 1;
          s += "rgba(" + t.r + "," + t.g + "," + t.b + "," + i + ")";
        }
      } else {
        const t = l.fill.color;
        const e = t.a !== undefined ? t.a : 1;
        s += "rgba(" + t.r + "," + t.g + "," + t.b + "," + e + ")";
      }
      let r = false;
      const d = parseFloat(window.getComputedStyle(i).transitionDuration) * 1000;
      let c;
      n.style.opacity = l.fill.alpha;
      if (s !== this.lastBgColors) {
        r = e && this.lastBgColors !== "" && n.style.background !== "";
        if (r) {
          i.style.opacity = 0;
          setTimeout(t => {
            n.style.background = s;
            i.style.opacity = 1;
          }, d);
        } else {
          i.style.opacity = 1;
          n.style.background = s;
        }
      }
      this.lastBgColors = s;
      c = l.fill.image.active === 1 && l.fill.image.src ? async t => {
        const e = l.fill.image.size;
        let i = TextEditorUtil.normalizeImageSrc(l.fill.image.src);
        let n;
        if ((i?.endsWith(".svg") || TextEditorUtil.isSvgFromDataURL(i)) && e === "stretch") {
          i = await TextEditorUtil.getSvgStretchableSrc(i);
        }
        if (a.style.backgroundImage !== i) {
          a.style.backgroundImage = "url(\"" + i + "\")";
        }
        n = e === "cover" || e === "contain" ? e : e === "stretch" || isNaN(e) ? "100% 100%" : e * 100 + "%";
        a.style.backgroundSize = n;
        a.style.backgroundRepeat = l.fill.image.repeat;
        a.style.backgroundPosition = "center";
        a.style.opacity = l.fill.image.alpha;
      } : t => {
        a.style.background = "";
      };
      const u = l.composite === "destination-over";
      let g = l.composite === "source-over" || u ? "normal" : l.composite;
      if (g === "lighter") {
        g = "plus-lighter";
      }
      o.style.mixBlendMode = g;
      i.style.zIndex = u ? 2 : 0;
      if (r) {
        setTimeout(c, d - 10);
      } else {
        c();
      }
    },
    _0xf5b7cf: function () {
      const t = getById("tt-background");
      this.textEditor.canvas;
      this.tt;
      const e = this.tt.getBoundingClientRect();
      const i = getById("tt-options").getBoundingClientRect();
      const n = this.tt.offsetWidth;
      const a = n < 900 ? i.top - e.top : e.height;
      Object.assign(t.style, {
        top: "0px",
        left: "0px",
        width: "100%",
        height: a + "px"
      });
    },
    _0x3225da: function () {
      const t = this;
      let e;
      let i;
      const n = getById("tt-animation-list").querySelector("ul");
      const a = getById("tt-animation-active-input");
      const o = getById("tt-animation-id-input");
      const l = this.textEditor.canvas;
      const s = TextEditorControls._0x12599a;
      const r = TextEditorUtil.getText("animations-label");
      for (const t in s) {
        const e = s[t];
        const i = r[e.id];
        s[t].label = i || e.id;
      }
      s.sort((t, e) => t.label > e.label || e.id === "" ? 1 : -1);
      const d = s.length;
      for (let l = 0; l < d; l++) {
        i = s[l];
        e = document.createElement("li");
        e.setAttribute("data-animation-id", i.id);
        e.setAttribute("data-animation-scale", i.scale ?? "1");
        if (i.premium) {
          e.classList.add("tt-premium");
        }
        e.title = i.label;
        e.innerHTML = "<div class=\"tt-icon\"><div class=\"ld ld-" + i.id + "\"></div></div><div class=\"tt-name\">" + i.label + "</div>";
        n.append(e);
        e.addEventListener("click", function (e) {
          const i = this.getAttribute("data-animation-id");
          this.getAttribute("data-animation-scale");
          const n = t._0xec2862(i).premium;
          t._0x5a772c(n, function () {
            if (a.checked === false) {
              a.checked = true;
              let e = t.textEditor.config;
              e.animation.active = 1;
              t.textEditor.config = e;
              t._0x5050df();
            }
            o.value = i;
            t._0x18e0e7 = true;
            o.dispatchEvent(new Event("change"));
            t._0x18e0e7 = false;
          });
        });
      }
      l.addEventListener("animationend", function () {
        const e = t.textEditor.canvas;
        const i = t.textEditor.config.animation;
        getById("tt-animation-list").querySelector("ul");
        if (t._0x34d86e) {
          clearTimeout(t._0x34d86e);
        }
        if (i.active !== 0 && i.id && e.style.animationIterationCount !== "infinite") {
          let n = e.className;
          e.className = "";
          t._0x34d86e = setTimeout(function () {
            e.className = n;
          }, i.pause);
        }
      });
      getById("tt-animation-search-input").addEventListener("input", function () {
        const t = this.value.toLowerCase().trim();
        const i = getById("tt-animation-list").querySelectorAll("li");
        let n = 0;
        for (let a = 0; a < i.length; a++) {
          e = i[a];
          if (t != "" && e.querySelector(".tt-name").innerHTML.toLowerCase().indexOf(t) === -1) {
            e.style.display = "none";
          } else {
            e.style.display = "block";
            n++;
          }
        }
        getById("tt-animation-list-no-result").style.display = n ? "none" : "block";
      });
    },
    _0xec2862: function (t) {
      const e = TextEditorControls._0x12599a;
      const i = e.length;
      for (let n = 0; n < i; n++) {
        if (e[n].id === t) {
          return e[n];
        }
      }
      return false;
    },
    _0x319b75: function (t) {
      const e = this;
      const i = this.textEditor.canvas;
      const n = t.animation;
      const a = getById("tt-animation-list").querySelector("ul");
      if (n.active !== 1) {
        i.className = "";
        return;
      }
      let o;
      let l;
      let s = a.querySelectorAll("li");
      for (let t = 0; t < s.length; t++) {
        o = s[t];
        l = o.getAttribute("data-animation-id");
        if (l !== n.id) {
          o.classList.remove("selected");
        } else {
          i.className = "";
          i.classList.add("ld", "ld-" + l);
          i.style.animationPlayState = "running";
          i.style.animationDelay = "0";
          i.style.animationDuration = n.duration + "ms";
          i.style.animationIterationCount = n.pause == "0" ? "infinite" : "1";
          o.classList.add("selected");
          if (e._0x34d86e) {
            clearTimeout(e._0x34d86e);
          }
        }
      }
    },
    _0x45ad17: 25,
    _0x4d1282: function () {
      return this.tt.getAttribute("data-user-premium") === "1";
    },
    _0x2bcc22: function () {
      const t = this;
      const e = this.tt.querySelectorAll("a[data-premium-link]");
      for (let i = 0; i < e.length; i++) {
        e[i].addEventListener("click", async function (e) {
          e.stopPropagation();
          e.preventDefault();
          const i = this;
          t.setLoadingInterface(true);
          try {
            const e = await t._0x5825d4("premium-popup-button");
            if (window.history) {
              let t = removeParam("userPresetId", window.location.href);
              t = t + (t.indexOf("?") !== -1 ? "&" : "?") + "userPresetId=" + e;
              history.pushState({}, "", t);
            }
            let n = i.href;
            if (!/userPresetId/.test(n)) {
              n += n.indexOf("?") === -1 ? "?" : "&";
              n += "userPresetId=" + e;
            }
            t.preventConfigHasChanged = false;
            window.location.href = n;
          } catch (e) {
            t._0x336896(e.message, "error");
          }
          t.setLoadingInterface(false);
        });
      }
    },
    _0x5a772c: function (t, e, i, n = {}) {
      if (t || !e) {
        if (this._0x4d1282()) {
          if (e) {
            e();
          }
        } else {
          const t = getById("tt-premium-popup");
          if (!this._0x285323) {
            this._0x285323 = true;
            t.addEventListener("click", function (e) {
              if (e.target === this || e.target.classList.contains("tt-close")) {
                t.style.display = "none";
              }
            });
          }
          t.style.display = "flex";
          let e = n.showLimitReachedMessage ? "add" : "remove";
          t.querySelector(".tt-limit-reached").classList[e]("tt-show");
          e = n.showPremiumLockedMessage ? "add" : "remove";
          t.querySelector(".tt-premium-locked").classList[e]("tt-show");
          if (i) {
            i();
          }
        }
      } else {
        e();
      }
    },
    _0x5825d4: async function (t) {
      const e = this;
      return new Promise(async (i, n) => {
        const a = JSON.stringify(e.textEditor.config, null, 2);
        const o = new Blob([a], {
          type: "application/json"
        });
        const l = await e._0x3a90ab({
          fontPixelSize: 100,
          aspectRatio: "16:9"
        });
        if (l && l.width !== 0 && l.height !== 0) {
          await e._0x5847c1([l]);
          l.toBlob(function (a) {
            const l = e.tt;
            const s = l.getAttribute("data-preset-id");
            const r = l.getAttribute("data-user-preset-id");
            let d = "ajax/preset";
            d += "?presetId=" + s;
            d += "&userPresetId=" + r;
            d += "&from=" + t;
            d += "&saveUserPreset=1";
            const c = new FormData();
            c.append("preview_image", a);
            c.append("preset_json", o);
            fetch(url(d), {
              method: "POST",
              body: c
            }).then(t => t.json()).then(t => {
              if (t.done) {
                i(r);
              } else if (t.error) {
                n(new Error(t.error));
              } else {
                n(new Error("Servor error"));
              }
            }).catch(t => {
              console.log(t);
              n(t);
            });
          });
        } else {
          e.setLoadingInterface(false);
        }
      });
    },
    _0x57719c: function () {
      const t = this.textEditor.config;
      return t.background.active !== 1 || t.background.fill.alpha < 1;
    },
    _0xbd04e7: function () {
      const t = this;
      const e = getById("tt-download-size-list");
      const i = e.querySelectorAll("li");
      const n = getById("tt-download-size-input");
      const a = function (t) {
        if (t) {
          t.classList.add("selected");
          n.value = t.getAttribute("data-size");
        }
        for (let e = 0; e < i.length; e++) {
          if (t !== i[e]) {
            i[e].classList.remove("selected");
          }
        }
      };
      a(e.querySelector("li.selected"));
      for (let e = 0; e < i.length; e++) {
        i[e].addEventListener("click", function (e) {
          const i = this;
          const n = i.getAttribute("data-size");
          const o = ["big", "max"].includes(n);
          t._0x5a772c(o, function () {
            a(i);
          });
        });
      }
      getById("tt-download-ratio-input").addEventListener("change", function (e) {
        const i = e.target;
        const n = i.options[i.selectedIndex].getAttribute("data-premium") === "1";
        t._0x5a772c(n, null, () => {
          i.selectedIndex = 0;
        });
      });
      const o = getById("tt-download-format-list").querySelectorAll("li");
      getById("tt-download-format-input");
      for (let e = 0; e < o.length; e++) {
        o[e].addEventListener("click", function (e) {
          const i = this.getAttribute("data-format");
          const n = this.classList.contains("tt-premium");
          t._0x5a772c(n, function () {
            t._0x1e9d7e(i);
          });
        });
      }
      getById("tt-options-menu").addEventListener("displayed", function (e) {
        const i = t.textEditor.config;
        if (e.detail.name === "save") {
          let e;
          const n = getById("tt-download-size-list");
          const a = n.querySelector("li[data-size=\"max\"]");
          if (i.animation.active === 1 && i.animation.id) {
            e = ["apng", "webm", "mp4", "gif", "gif-hd", "frames", "preset", "textimage", "save"];
            if (!browserSupportCanvasWebp()) {
              e.splice(1, 1);
            }
            a.style.display = "none";
            if (a.classList.contains("selected")) {
              a.classList.remove("selected");
              n.querySelector("li[data-size=\"big\"]").classList.add("selected");
            }
          } else {
            e = ["png", "transparent-png", "jpg", "pdf", "preset", "textimage", "clipboard", "save"];
            if (t._0x57719c()) {
              e = e.filter(t => t !== "jpg");
            }
            a.style.display = "flex";
          }
          for (let t = 0; t < o.length; t++) {
            if (e.indexOf(o[t].getAttribute("data-format")) !== -1) {
              o[t].style.display = "flex";
            } else {
              o[t].style.display = "none";
            }
          }
          if (!("ClipboardItem" in window)) {
            getById("tt-download-format-list").querySelector("[data-format=\"clipboard\"]").style.display = "none";
          }
        }
      });
    },
    _0x1e9d7e: async function (t) {
      const e = this;
      if (getById("tt").getAttribute("data-pl")) {
        e._0x5a772c(true, false, false, {
          showPremiumLockedMessage: true
        });
        return true;
      }
      try {
        let t = url("ajax/check-download");
        const i = this.tt.getAttribute("data-preset-id");
        if (i) {
          t += "?presetId=" + i;
        }
        let n = await fetch(t);
        if (!n.ok || n.status != 200) {
          throw "Error";
        }
        n = await n.json();
        if (n.limitReached) {
          e._0x5a772c(true, false, false, {
            showLimitReachedMessage: true
          });
          return true;
        }
      } catch (t) {
        alert(TextEditorUtil.getText("error-check-connection"));
        return;
      }
      if (t === "preset") {
        e._0x1f6f0a();
        return;
      }
      if (this.textEditor.drawing) {
        alert(TextEditorUtil.getText("error-wait-moment"));
        return;
      }
      if (t === "save") {
        e._0x3a8019();
        return;
      }
      e.setLoadingInterface(true);
      getById("tt-download-size-input").value;
      const i = {};
      if (t !== "textimage" || isMobile()) {
        if (t === "gif" || t === "gif-hd") {
          i.maxSize = {
            small: 256,
            medium: 512,
            big: 768,
            max: 768
          };
        }
      } else {
        const t = getById("tt-download-size-input").value;
        if (e._0x4d1282() && ["small", "medium"].includes(t)) {
          i.fontSizeType = "big";
        } else if (t === "small") {
          i.fontSizeType = "medium";
        }
      }
      if (t === "clipboard" && TextEditorUtil.isIOS()) {
        try {
          const t = async () => {
            await new Promise(t => setTimeout(t, 100));
            const t = await e._0x3a90ab(i);
            await this._0x5847c1([t]);
            return await new Promise(e => t.toBlob(e));
          };
          await navigator.clipboard.write([new ClipboardItem({
            "image/png": t()
          })]);
          this._0x336896(TextEditorUtil.getText("copy-clipboard-success"));
        } catch (t) {
          console.log(t);
          this._0x336896(TextEditorUtil.getText("copy-clipboard-error"), "error");
        }
        this.setLoadingInterface(false);
        return;
      }
      await new Promise(t => setTimeout(t, 100));
      const n = await e._0x3a90ab(i);
      if (!n || n.width === 0 || n.height === 0) {
        this._0x336896("An unspecified error has occurred, please try again.", "error");
        e.setLoadingInterface(false);
        return;
      }
      switch (t) {
        case "png":
        case "transparent-png":
          const i = t === "png";
          e._0x37c8d7(n, i);
          break;
        case "jpg":
          e._0x35ae12(n);
          break;
        case "gif":
          e._0x54b52e(n);
          break;
        case "pdf":
          e._0x2ceda6(n);
          break;
        case "gif-hd":
          e._0xb7c0b5(n);
          break;
        case "apng":
          e._0x3a1b16(n);
          break;
        case "mp4":
          e._0x5c1f89(n);
          break;
        case "webm":
          e._0x4c52c4(n);
          break;
        case "frames":
          e._0x236b48(n);
          break;
        case "clipboard":
          e._0x129362(n);
          break;
        case "textimage":
          e._0x17297c(n);
      }
    },
    _0x166e32: async function (t) {
      const e = getById("tt-text-image-popup");
      if (!this.textImagePopupInitialized) {
        this.setLoadingInterface(true);
        const i = getById("timg");
        const n = i.getAttribute("data-js-files").split(",");
        const a = i.getAttribute("data-css-files").split(",");
        try {
          for (let t = 0; t < a.length; t++) {
            await loadCssFileAsync(a[t]);
          }
          for (let t = 0; t < n.length; t++) {
            await loadScriptFileAsync(n[t]);
          }
        } catch (t) {
          alert(TextEditorUtil.getText("error-check-connection"));
          this.setLoadingInterface(false);
          return;
        }
        e.addEventListener("click", function (i) {
          if (i.target.classList.contains("tt-close")) {
            e.style.display = "none";
            document.body.style.overflow = "auto";
            getById("timg-object-toolbox").style.display = "none";
            t.width = t.height = 0;
            const i = e.querySelector("img, video");
            if (i && i.src.startsWith("blob:")) {
              URL.revokeObjectURL(i.src);
            }
          }
        });
        this.textImagePopupInitialized = true;
        window.timg.init();
      }
      window.timg.addImage(t.toDataURL());
      document.body.style.overflow = "hidden";
      this.setLoadingInterface(false);
      e.style.display = "flex";
    },
    _0x17297c: function (t) {
      this._0x166e32(t);
    },
    _0x129362: async function (t) {
      try {
        await this._0x5847c1([t]);
        const e = await new Promise(e => t.toBlob(e));
        const i = [new ClipboardItem({
          [e.type]: e
        })];
        await navigator.clipboard.write(i);
        this._0x336896(TextEditorUtil.getText("copy-clipboard-success"));
      } catch (t) {
        alert(t);
        console.log(t);
        this._0x336896(TextEditorUtil.getText("copy-clipboard-error"), "error");
      } finally {
        this.setLoadingInterface(false);
      }
    },
    _0x3a8019: async function (t) {
      this.setLoadingInterface(true);
      try {
        await this._0x5825d4("save-button");
        this._0x336896(TextEditorUtil.getText("saved-success"));
        this.preventConfigHasChanged = false;
      } catch (t) {
        this._0x336896(t.message, "error");
      }
      this.setLoadingInterface(false);
    },
    _0x37c8d7: async function (t, e) {
      const i = this;
      if (e) {
        await i._0x5847c1([t]);
      }
      t.toBlob(function (e) {
        i._0x4e65af(e, "png", t.width, t.height);
        i.setLoadingInterface(false);
      });
    },
    _0x35ae12: async function (t) {
      const e = this;
      await e._0x5847c1([t]);
      t.toBlob(function (i) {
        e._0x4e65af(i, "jpg", t.width, t.height);
        e.setLoadingInterface(false);
      }, "image/jpeg", 0.92);
    },
    _0x2ceda6: async function (t) {
      const e = this;
      try {
        await e._0x5847c1([t]);
        if (typeof jspdf == "undefined") {
          await loadScriptFileAsync(url("asset/editor/jspdf.umd.min.js"));
        }
        const {
          width: i,
          height: n
        } = t;
        const a = i > n ? "l" : "p";
        const o = new jspdf.jsPDF({
          orientation: a,
          unit: "pt",
          format: [t.width, t.height]
        });
        const l = o.internal.pageSize.getWidth();
        const s = o.internal.pageSize.getHeight();
        o.addImage(t, "PNG", 0, 0, l, s);
        const r = o.output("blob");
        e._0x4e65af(r, "pdf", t.width, t.height);
        e.setLoadingInterface(false);
      } catch (t) {
        const i = TextEditorUtil.getText("error-check-connection");
        e._0x336896(i, "error");
        e.setLoadingInterface(false);
      }
    },
    _0x54b52e: function (t) {
      const e = this;
      const n = this.textEditor.config;
      e._0x131616(t, 800, async function (t) {
        await e._0x5847c1(t);
        const a = new GIF({
          workers: 2,
          quality: 10,
          transparent: n.background.active === 1 ? null : "rgba(0,0,0,0)",
          workerScript: url("asset/editor/gif.worker.min.js", false)
        });
        let o;
        for (let i = 0; i < t.length; i++) {
          o = i === 0 && n.animation.pause ? n.animation.pause : 1 / e._0x45ad17 * 1000;
          a.addFrame(t[i], {
            delay: o
          });
        }
        a.on("finished", function (n) {
          e._0x4e65af(n, "gif", t[0].width, t[0].height);
          e.setLoadingInterface(false);
          i = 0;
          for (; i < t.length; i++) {
            t[i].width = t[i].height = 0;
          }
        });
        a.on("progress", function (t) {
          const i = Math.round(t * 100);
          e.setLoadingInterface(true, i);
        });
        a.render();
      });
    },
    _0xb7c0b5: function (t) {
      const e = this;
      const n = this.textEditor.config;
      e._0x131616(t, 1200, async function (t) {
        await e._0x5847c1(t);
        const a = TextEditorUtil.generateUUID();
        const o = function (i) {
          const n = Math.round(i / t.length * 100);
          e.setLoadingInterface(true, n);
          (function (t, e, i) {
            t.toBlob(function (n) {
              t.width = t.height = 0;
              const o = new FormData();
              o.append("image", n);
              fetch(url("ajax/gif?gifId=" + a + "&frame=" + e), {
                method: "POST",
                body: o
              }).then(t => {
                if (t.ok) {
                  i();
                } else {
                  s();
                }
              }).catch(t => {
                s();
              });
            });
          })(t[i], i, function () {
            if (i + 1 < t.length) {
              o(i + 1);
            } else {
              l();
            }
          });
        };
        const l = function () {
          const o = [];
          for (i = 0; i < t.length; i++) {
            if (i === 0 && n.animation.pause) {
              o.push(n.animation.pause);
            } else {
              o.push(1 / e._0x45ad17 * 1000);
            }
          }
          fetch(url("ajax/gif?create=1&gifId=" + a + "&delays=" + o.join(","))).then(t => {
            if (t.ok) {
              return t.json();
            }
            s();
          }).then(async t => {
            if (t.file) {
              try {
                const i = await fetch(t.file).then(t => t.blob());
                e._0x4e65af(i, "gif", t.width, t.height);
              } catch (t) {
                console.log(t);
              }
              e.setLoadingInterface(false);
            } else {
              s();
            }
          }).catch(t => {
            s();
          });
        };
        const s = function () {
          e.setLoadingInterface(false);
        };
        o(0);
      });
    },
    _0x3a1b16: function (t) {
      const e = this;
      const i = this.textEditor.config;
      const n = isMobile() ? 800 : 1200;
      e._0x131616(t, n, async function (t) {
        await e._0x5847c1(t);
        let n;
        let a;
        let o = [];
        let l = [];
        for (let s = 0; s < t.length; s++) {
          n = t[s];
          a = n.getContext("2d").getImageData(0, 0, n.width, n.height).data.buffer;
          o.push(a);
          if (s === 0 && i.animation.pause) {
            delay = i.animation.pause;
          } else {
            delay = 1 / e._0x45ad17 * 1000;
          }
          l.push(delay);
        }
        const s = UPNG.encode(o, t[0].width, t[0].height, 0, l);
        const r = new Uint8Array(s);
        const d = new Blob([r], {
          type: "image/apng"
        });
        e._0x4e65af(d, "png", t[0].width, t[0].height);
        e.setLoadingInterface(false);
        for (let e = 0; e < t.length; e++) {
          t[e].width = t[e].height = 0;
        }
      });
    },
    _0x4c52c4: function (t) {
      const e = this;
      const n = this.textEditor.config;
      let a;
      let o;
      e._0x131616(t, 1200, async function (t) {
        await e._0x5847c1(t);
        const l = TextEditorUtil.generateUUID();
        const s = function (i) {
          const n = Math.round(i / t.length * 100);
          e.setLoadingInterface(true, n);
          (function (t, e, i) {
            a = t.width;
            o = t.height;
            t.toBlob(function (n) {
              t.width = t.height = 0;
              const a = new FormData();
              a.append("image", n);
              fetch(url("ajax/webm?webmId=" + l + "&frame=" + e), {
                method: "POST",
                body: a
              }).then(t => {
                if (t.ok) {
                  return t.json();
                }
                d();
              }).then(t => {
                if (t.done) {
                  i();
                } else {
                  d(t.error);
                }
              }).catch(t => {
                d();
              });
            });
          })(t[i], i, function () {
            if (i + 1 < t.length) {
              s(i + 1);
            } else {
              r();
            }
          });
        };
        const r = function () {
          const s = [];
          for (i = 0; i < t.length; i++) {
            if (i === 0 && n.animation.pause) {
              s.push(n.animation.pause / 1000);
            } else {
              s.push(1 / e._0x45ad17);
            }
          }
          fetch(url("ajax/webm?create=1&webmId=" + l + "&delays=" + s.join(","))).then(t => {
            if (t.ok) {
              return t.json();
            }
            console.log(t);
            d();
          }).then(async t => {
            if (t.file) {
              try {
                const i = await fetch(t.file).then(t => t.blob());
                e._0x4e65af(i, "webm", a, o);
              } catch (t) {
                console.log(t);
              }
              e.setLoadingInterface(false);
            } else {
              console.log(t);
              d(t.error);
            }
          }).catch(t => {
            console.log(t);
            d();
          });
        };
        const d = function (t) {
          if (t) {
            e._0x336896(t, "error");
          }
          e.setLoadingInterface(false);
        };
        s(0);
      });
    },
    _0x5c1f89: function (t) {
      const e = this;
      const i = this.textEditor.config;
      const n = isMobile() ? 800 : 1600;
      if (t.width % 2 != 0 || t.height % 2 != 0) {
        let e = t.width;
        let i = t.height;
        if (t.width % 2 != 0) {
          e -= 1;
        }
        if (t.height % 2 != 0) {
          i -= 1;
        }
        const n = document.createElement("canvas");
        const a = n.getContext("2d");
        n.width = e;
        n.height = i;
        a.drawImage(t, 0, 0, t.width, t.height, 0, 0, e, i);
        t.width = t.height = 0;
        t = n;
      }
      e._0x131616(t, n, async function (t) {
        async function n() {
          const n = await HME.createH264MP4Encoder();
          n.width = t[0].width;
          n.height = t[0].height;
          n.frameRate = e._0x45ad17;
          n.initialize();
          for (let a = 0; a < t.length; a++) {
            const o = t[a].getContext("2d").getImageData(0, 0, n.width, n.height).data;
            if (a === 0 && i.animation.pause) {
              const t = e._0x45ad17 * (i.animation.pause / 1000);
              for (let e = 0; e < t; e++) {
                n.addFrameRgba(o);
              }
            } else {
              n.addFrameRgba(o);
            }
          }
          n.finalize();
          let a = n.FS.readFile(n.outputFilename);
          n.delete();
          const o = new Blob([a.buffer]);
          a = null;
          e._0x4e65af(o, "mp4", n.width, n.height);
          e.setLoadingInterface(false);
        }
        await e._0x5847c1(t);
        if (e._0x549807) {
          n();
        } else {
          loadScript(url("asset/editor/h264-mp4-encoder.web.js"), true, async t => {
            if (t) {
              e._0x549807 = true;
              n();
            } else {
              e.setLoadingInterface(false);
            }
          });
        }
      });
    },
    _0x236b48: function (t) {
      const e = this;
      this.textEditor.config;
      const n = function (t, e, i, a) {
        const o = e[i];
        const l = i.toString().padStart(2, "0");
        o.toBlob(function (s) {
          o.width = o.height = 0;
          t.file("frames-" + l + ".png", s);
          if (i < e.length - 1) {
            n(t, e, i + 1, a);
          } else {
            a();
          }
        });
      };
      e._0x131616(t, 1920, async function (t) {
        await e._0x5847c1(t);
        var a = new JSZip();
        n(a, t, 0, function () {
          a.generateAsync({
            type: "blob"
          }).then(function (n) {
            e._0x4e65af(n, "zip", t[0].width, t[0].height);
            e.setLoadingInterface(false);
            i = 0;
            for (; i < t.length; i++) {
              t[i].width = t[i].height = 0;
            }
          });
        });
      });
    },
    _0x1f6f0a: function () {
      let t = JSON.stringify(this.textEditor.config, null, 2);
      let e = this._0x2d899d(this.textEditor.config.text, "textstudio");
      TextEditorUtil.download(t, e, "text/plain");
      this.setLoadingInterface(false);
    },
    _0x2d899d: function (t, e) {
      const i = new Date().toLocaleDateString(undefined, {
        year: "numeric",
        month: "numeric",
        day: "numeric"
      });
      let n = t.replace(/\n/g, "-").trim().substring(0, 30);
      n += "-" + i;
      n = n.replace(/([^a-z0-9]+)/gi, "-");
      return n + "." + e;
    },
    _0x4e65af(t, e, i, n) {
      const a = this;
      const o = getById("tt-download-popup");
      const l = o.querySelector(".tt-drop-media");
      const s = o.querySelector(".tt-size");
      const r = o.querySelector(".tt-download-button");
      const d = o.querySelector(".tt-hosting-button");
      const c = o.querySelector(".tt-hosting-container");
      const u = c.querySelector("textarea");
      this._0x2c1360 = t;
      if (!this._0x1dc6e9) {
        this._0x1dc6e9 = true;
        o.addEventListener("click", function (t) {
          if (t.target === this || t.target.classList.contains("tt-close")) {
            o.style.display = "none";
            const t = o.querySelector("img, video");
            if (t && t.src.startsWith("blob:")) {
              URL.revokeObjectURL(t.src);
            }
            a._0x2c1360 = null;
          }
        });
        r.addEventListener("click", async function (t) {
          const e = l.querySelector("[data-format]").getAttribute("data-format");
          const i = a._0x2d899d(a.textEditor.config.text, e);
          saveAs(a._0x2c1360, i);
          if (!a._0x4d1282()) {
            o.classList.add("downloaded-no-premium");
          }
        });
        d.addEventListener("click", function (t) {
          a._0x5a772c(true, async t => {
            a.setLoadingInterface(true);
            const e = l.querySelector("[data-format]");
            e.getAttribute("data-format");
            const i = await TextEditorUtil.fetch(e.src, "blob", true);
            if (!i) {
              alert(TextEditorUtil.getText("error-reading-image"));
              return;
            }
            const n = new FormData();
            n.append("image", i);
            fetch(url("ajax/hosting"), {
              method: "POST",
              body: n
            }).then(t => t.json()).then(t => {
              if (t.image_tag) {
                c.classList.add("tt-show");
                d.classList.remove("tt-show");
                u.value = t.image_tag;
              } else if (t.error) {
                a._0x336896(t.error, "error");
              } else if (t.message) {
                a._0x336896(t.message, "report");
              } else {
                const t = TextEditorUtil.getText("error-check-connection");
                a._0x336896(t, "error");
              }
            }).catch(t => {
              console.log(t);
              const e = TextEditorUtil.getText("error-check-connection");
              a._0x336896(e, "error");
            }).finally(t => {
              a.setLoadingInterface(false);
            });
          });
        });
        u.addEventListener("focus", function (t) {
          this.select();
          document.execCommand("copy");
          a._0x336896(this.getAttribute("data-copied-text"));
        });
        a._0x4d1282();
      }
      o.classList.remove("downloaded-no-premium");
      c.classList.remove("tt-show");
      l.innerHTML = s.innerHTML = "";
      o.style.display = "flex";
      let g;
      let h;
      let p = false;
      switch (e) {
        case "gif":
        case "png":
        case "jpg":
          p = true;
          g = document.createElement("img");
          g.onload = function () {
            s.innerHTML = this.naturalWidth + " x " + this.naturalHeight;
          };
          h = URL.createObjectURL(t);
          g.src = h;
          g.width = i;
          g.height = n;
          break;
        case "webm":
        case "mp4":
          g = document.createElement("video");
          g.autoplay = true;
          g.loop = true;
          g.onloadedmetadata = function () {
            s.innerHTML = this.videoWidth + " x " + this.videoHeight;
          };
          h = URL.createObjectURL(t);
          g.src = h;
          g.width = i;
          g.height = n;
          break;
        case "zip":
          g = document.createElement("img");
          g.src = url("asset/editor/zip-download-icon.svg");
          g.classList.add("tt-zip-icon");
          g.width = 1024;
          g.height = 1024;
          break;
        case "pdf":
          g = document.createElement("img");
          g.src = url("asset/editor/pdf-download-icon.svg");
          g.classList.add("tt-pdf-icon");
          g.width = 1024;
          g.height = 1024;
      }
      g.setAttribute("data-format", e);
      if (h) {
        const t = document.createElement("a");
        t.href = h;
        t.target = "_blank";
        t.append(g);
        l.append(t);
      } else {
        l.append(g);
      }
      if (p) {
        d.classList.add("tt-show");
      } else {
        d.classList.remove("tt-show");
      }
    },
    _0x336896: function (t, e) {
      Toastify({
        text: t,
        escapeMarkup: false,
        duration: 3000,
        close: true,
        gravity: "top",
        position: "center",
        className: e ? "toastify-" + e : "",
        stopOnFocus: true,
        offset: {
          x: 0,
          y: 0
        },
        onClick: function () {}
      }).showToast();
    },
    _0x131616: function (t, e, i) {
      const n = this;
      const a = this.textEditor.config;
      if (!a.animation.id || a.animation.active !== 1) {
        i([t]);
        return;
      }
      const o = n._0x45ad17 * (a.animation.duration / 1000);
      Animate.getFrames({
        imageSrc: t.toDataURL(),
        effectId: a.animation.id,
        maxSize: e,
        smartCrop: false,
        nbFrames: o,
        spacing: 0,
        onSuccess: function (t) {
          i(t);
        },
        onError: function (t) {
          alert(TextEditorUtil.getText("error-creating-animation") + "\n" + t);
          n.setLoadingInterface(false);
        }
      });
    },
    _0x59f9d3: function () {
      const t = getById("tt-download-spacing-input");
      if (t.value) {
        return parseFloat(t.value);
      } else {
        return 0;
      }
    },
    _0x5847c1: async function (t) {
      const e = this.textEditor.config.background;
      if (e.active === 1 && t && t[0] && t[0].width > 0) {
        const i = document.createElement("canvas");
        const n = i.getContext("2d");
        i.width = t[0].width;
        i.height = t[0].height;
        await TextEditorUtil.drawBackgroundCanvas(n, e);
        if (e.composite !== "source-over") {
          for (const n of t) {
            const t = TextEditorUtil.cloneCanvas(n);
            const a = n.getContext("2d");
            a.save();
            a.globalCompositeOperation = "copy";
            a.drawImage(i, 0, 0);
            a.globalCompositeOperation = e.composite;
            a.drawImage(t, 0, 0);
            a.restore();
            t.width = t.height = 0;
          }
        } else {
          for (const e of t) {
            const t = e.getContext("2d");
            t.save();
            t.globalCompositeOperation = "destination-over";
            t.drawImage(i, 0, 0);
            t.restore();
          }
        }
        i.width = i.height = 0;
      }
    },
    _0x3a90ab: async function (t = {}) {
      const e = this;
      const i = e.textEditor.config;
      this._0x135de6(i);
      const n = e._0x4d1282();
      const a = TextEditorUtil.cloneObject(i);
      const o = t.aspectRatio ? t.aspectRatio : getById("tt-download-ratio-input").value;
      const l = t.fontSizeType ? t.fontSizeType : getById("tt-download-size-input").value;
      const s = e._0x59f9d3();
      let r = maxHeight = 5120;
      let d = t.fontPixelSize ? t.fontPixelSize : null;
      if (!d) {
        switch (l) {
          case "small":
            d = 75;
            r = maxHeight = t?.maxSize?.small ?? 256;
            break;
          case "medium":
            d = 600;
            r = maxHeight = t?.maxSize?.medium ?? 1024;
            break;
          case "big":
            d = 1000;
            r = maxHeight = t?.maxSize?.big ?? 2560;
            break;
          case "max":
            d = 1600;
            r = maxHeight = t?.maxSize?.max ?? 5120;
        }
      }
      i.font.size = d;
      if (!n) {
        r = 1024;
        maxHeight = 1024;
      }
      const c = getById("tt-api-generate-input")?.checked;
      if ((isMobile() || c ? "api" : "local") === "api") {
        try {
          if (r > 3072) {
            r = 3072;
          }
          if (maxHeight > 3072) {
            maxHeight = 3072;
          }
          i.background.active = 0;
          const t = new FormData();
          t.append("textConfig", JSON.stringify(i));
          t.append("format", "webp");
          t.append("maxWidth", r);
          t.append("maxHeight", maxHeight);
          t.append("aspectRatio", o);
          t.append("padding", s * 100);
          const n = "https://api-gen.textstudio.com/";
          const l = await fetch(n, {
            method: "POST",
            body: t
          });
          const d = await l.blob();
          const c = URL.createObjectURL(d);
          const u = await TextEditorUtil.getImg(c);
          if (u) {
            const t = document.createElement("canvas");
            const i = t.getContext("2d");
            t.width = u.naturalWidth;
            t.height = u.naturalHeight;
            i.drawImage(u, 0, 0);
            URL.revokeObjectURL(c);
            e.textEditor.setConfig(a);
            return t;
          }
        } catch (t) {
          e.textEditor.setConfig(a);
          e.setLoadingInterface(false);
          return;
        }
      }
      e.textEditor.setConfig(i);
      await e.textEditor.draw({
        isPostTreatment: true,
        isBestQuality: true,
        maxWidth: r,
        maxHeight: maxHeight
      });
      e.textEditor.config = a;
      let u;
      let g;
      let h = e.textEditor.canvas;
      if (h.width < 2) {
        alert(TextEditorUtil.getText("error-empty-canvas"));
        e.setLoadingInterface(false);
        return;
      }
      try {
        u = TextEditorUtil.trimCanvas(h, true, 1);
      } catch (t) {
        console.log(t);
      }
      if (!u) {
        alert(TextEditorUtil.getText("error-drawing-canvas"));
        e.setLoadingInterface(false);
        return;
      }
      g = {
        x: u.width * s,
        y: u.width * s
      };
      const p = document.createElement("canvas");
      const f = p.getContext("2d");
      const b = u.width + g.x * 2;
      const m = u.height + g.y * 2;
      if (o === "fit") {
        p.width = b;
        p.height = m;
        f.drawImage(h, u.x, u.y, u.width, u.height, g.x, g.y, u.width, u.height);
        h.width = h.height = 0;
        h = p;
      } else {
        let t;
        let e;
        let i = o.split(":");
        i = parseInt(i[0]) / parseInt(i[1]);
        if (b / m > i) {
          e = b / i;
          t = b;
        } else {
          t = m * i;
          e = m;
        }
        p.width = t;
        p.height = e;
        f.drawImage(h, u.x, u.y, u.width, u.height, g.x + (t - b) / 2, g.y + (e - m) / 2, u.width, u.height);
        h.width = h.height = 0;
        h = p;
      }
      if (h.width > r || h.height > maxHeight) {
        const t = TextEditorUtil.thumbnailImageCanvas(h, r, maxHeight);
        h.width = h.height = 0;
        h = t;
      }
      e.textEditor.setConfig(a);
      e.textEditor.draw({
        isPostTreatment: true
      });
      return h;
    },
    setLoadingCanvas: function (t) {
      getById("tt-canvas-loading").style.display = t ? "block" : "none";
    },
    setLoadingInterface: function (t, e) {
      const i = this.tt;
      const n = getById("tt-loading-popup").querySelector(".tt-percent");
      if (t) {
        if (!i.classList.contains("tt-loading")) {
          i.classList.add("tt-loading");
        }
        if (e) {
          n.innerHTML = e + "%";
        }
      } else {
        i.classList.remove("tt-loading");
        n.innerHTML = "";
      }
    },
    _0x135de6: function (t) {
      return t.animation.active === 1 && t.animation.id;
    },
    _0x3a3054: function (onlyThisRangeNode) {
      const allRanges = onlyThisRangeNode ? [onlyThisRangeNode] : this.tt.querySelectorAll("[data-bubble]");
      function setBubble(range, bubble) {
        const formula = range.getAttribute("data-bubble").replace(/V/g, range.value);
        const text = eval("(" + formula + ")");
        const val = range.value;
        const min = range.min ? range.min : 0;
        const max = range.max ? range.max : 100;
        const newVal = Number((val - min) * 100 / (max - min));
        bubble.innerHTML = text;
        bubble.style.left = "calc(" + newVal + "% + (" + (8 - newVal * 0.15) + "px))";
      }
      allRanges.forEach(t => {
        const e = t.parentNode;
        const i = t.nextSibling;
        const n = document.createElement("div");
        n.classList.add("tt-range-bubble");
        n.appendChild(t);
        const a = document.createElement("output");
        n.appendChild(a);
        if (i) {
          e.insertBefore(n, i);
        } else {
          e.appendChild(n);
        }
        t.addEventListener("input", e => {
          if (e.isTrusted) {
            a.style.display = "block";
            setBubble(t, a);
          }
        });
        t.addEventListener("blur", () => {
          a.style.display = "none";
        });
        t.addEventListener("mouseup", () => {
          a.style.display = "none";
        });
        t.addEventListener("touchend", () => {
          a.style.display = "none";
        });
        setBubble(t, a);
      });
    },
    _0x551df3: function () {
      const t = this;
      this._0x369da6 = new FontSelector($("#tt-font-src-input"), $("#tt-font-name-input"));
      this.textEditor.on("fontLoading", function (e, i, n) {
        t.setLoadingCanvas(true);
      });
      this.textEditor.on("fontLoaded", function (e, i, n, a) {
        t._0x369da6.onFontLoaded(e, i, n);
      });
    },
    _0x343198: function () {
      const t = this;
      const e = this.tt.querySelectorAll(".tt-align-list");
      for (const i of e) {
        const e = i.querySelectorAll("li");
        for (const n of e) {
          n.addEventListener("click", function (e) {
            const n = getById(i.getAttribute("data-input"));
            n.value = this.getAttribute("data-id");
            n.dispatchEvent(new Event("change"));
            t._0x19e7bc();
          });
        }
      }
    },
    _0x19e7bc: function () {
      const t = this.tt.querySelectorAll(".tt-align-list");
      for (const e of t) {
        const t = getById(e.getAttribute("data-input")).value;
        const i = e.querySelectorAll("li");
        for (const e of i) {
          if (e.getAttribute("data-id") === t) {
            e.classList.add("selected");
          } else {
            e.classList.remove("selected");
          }
        }
      }
    },
    _0x15de4f: function () {
      const t = this.tt.querySelectorAll(".tt-font-options-list");
      const e = this;
      for (const i of t) {
        const t = i.querySelectorAll("li");
        for (const i of t) {
          i.addEventListener("click", function (t) {
            const i = getById(this.getAttribute("data-input"));
            if (i.value === this.getAttribute("data-selected")) {
              i.value = this.getAttribute("data-unselected");
            } else {
              i.value = this.getAttribute("data-selected");
            }
            i.dispatchEvent(new Event("change"));
            e._0x47a579();
          });
        }
      }
    },
    _0x47a579: function () {
      const t = this.tt.querySelectorAll(".tt-font-options-list");
      for (const e of t) {
        const t = e.querySelectorAll("li");
        for (const e of t) {
          if (getById(e.getAttribute("data-input")).value === e.getAttribute("data-selected")) {
            e.classList.add("selected");
          } else {
            e.classList.remove("selected");
          }
        }
      }
    },
    _0x16a825: function () {
      const t = this.tt.querySelectorAll(".tt-outline-join-list");
      const e = this;
      for (const i of t) {
        const t = i.querySelectorAll("li");
        for (const n of t) {
          n.addEventListener("click", function (t) {
            const n = getById(i.getAttribute("data-input"));
            n.value = this.getAttribute("data-id");
            n.dispatchEvent(new Event("change"));
            e._0x18f97b();
          });
        }
      }
    },
    _0x18f97b: function () {
      const t = this.tt.querySelectorAll(".tt-outline-join-list");
      for (const e of t) {
        const t = e.querySelectorAll("li");
        const i = getById(e.getAttribute("data-input")).value;
        for (const e of t) {
          if (e.getAttribute("data-id") === i) {
            e.classList.add("selected");
          } else {
            e.classList.remove("selected");
          }
        }
      }
    },
    onDrawStart: function () {
      if (!this.alreadyDrawn) {
        this.setLoadingCanvas(true);
      }
    },
    onDrawFinish: function () {
      this._0xf5b7cf();
      this._0x49ba7e(this.textEditor.config, null);
      this.setLoadingCanvas(false);
      this.alreadyDrawn ||= true;
    }
  }._0x2b87cc();
}
TextEditorControls._0x12599a = [{
  id: "",
  name: "",
  premium: false
}, {
  id: "blink",
  name: "",
  premium: false
}, {
  id: "blur",
  name: "",
  premium: true
}, {
  id: "beat",
  name: "",
  premium: true
}, {
  id: "tick-alt",
  name: "",
  premium: false
}, {
  id: "jump",
  name: "",
  premium: false
}, {
  id: "bounce",
  name: "",
  premium: true
}, {
  id: "clock",
  name: "",
  premium: false
}, {
  id: "fade",
  name: "",
  premium: false
}, {
  id: "flip",
  name: "",
  premium: true
}, {
  id: "flip-h",
  name: "",
  premium: true
}, {
  id: "flip-v",
  name: "",
  premium: true
}, {
  id: "float",
  name: "",
  premium: true
}, {
  id: "heartbeat",
  name: "",
  premium: true
}, {
  id: "breath",
  name: "",
  premium: false
}, {
  id: "wander-v",
  name: "",
  premium: false
}, {
  id: "wander-h",
  name: "",
  premium: false
}, {
  id: "jingle",
  name: "",
  premium: false
}, {
  id: "rubber-v",
  name: "",
  premium: true
}, {
  id: "rubber-h",
  name: "",
  premium: true
}, {
  id: "shake-v",
  name: "",
  premium: true
}, {
  id: "shake-h",
  name: "",
  premium: true
}, {
  id: "tick",
  name: "",
  premium: true
}, {
  id: "smash",
  name: "",
  premium: false
}, {
  id: "jelly-alt",
  name: "",
  premium: false
}, {
  id: "jelly",
  name: "",
  premium: false
}, {
  id: "damage",
  name: "",
  premium: true
}, {
  id: "skew",
  name: "",
  premium: true
}, {
  id: "skew-alt",
  name: "",
  premium: true
}, {
  id: "slide-ltr",
  name: "",
  premium: false
}, {
  id: "slide-rtl",
  name: "",
  premium: false
}, {
  id: "slide-btt",
  name: "",
  premium: false
}, {
  id: "slide-ttb",
  name: "",
  premium: false
}, {
  id: "coin-h",
  name: "",
  premium: true
}, {
  id: "coin-v",
  name: "",
  premium: true
}, {
  id: "cycle",
  name: "",
  premium: true
}, {
  id: "cycle-alt",
  name: "",
  premium: true
}, {
  id: "spin",
  name: "",
  premium: true
}, {
  id: "squeeze",
  name: "",
  premium: true
}, {
  id: "surprise",
  name: "",
  premium: true
}, {
  id: "measure",
  name: "",
  premium: true
}, {
  id: "shiver",
  name: "",
  premium: false
}, {
  id: "swim",
  name: "",
  premium: false
}, {
  id: "tremble",
  name: "",
  premium: false
}, {
  id: "vortex",
  name: "",
  premium: true
}, {
  id: "vortex-alt",
  name: "",
  premium: true
}, {
  id: "hit",
  name: "",
  premium: true
}];
const Animate = {
  _0x4ab4f7: {
    cssFile: "asset/editor/" + (ONLINE ? "animate.min.css" : "~animate.css"),
    imageSrc: null,
    effectId: "heartbeat",
    maxSize: 400,
    smartCrop: true,
    nbFrames: 14,
    spacing: 0,
    onSucess: null,
    onError: null,
    onImageLoaded: null
  },
  getFrames: function (t) {
    const e = this;
    e._0x46869d(t);
    e._0x2795cf(function (t) {
      e._0x53d75e(e._0x4ab4f7.imageSrc, e._0x4ab4f7.maxSize, function (t, i, n) {
        let a = e._0x273966(e._0x4ab4f7.effectId);
        a = e._0x4a45ff(e._0x4ab4f7.effectId, a, i, n);
        const o = e._0x4dee42(a, t);
        const l = e._0x443ea4(o);
        l.querySelector("image");
        l.querySelector("g");
        l.setAttribute("data-original-width", i);
        l.setAttribute("data-original-height", n);
        e._0x5d3436(l, e._0x4ab4f7.maxSize, e._0x4ab4f7.smartCrop, e._0x4ab4f7.spacing);
        const s = {
          w: parseInt(l.getAttribute("width")),
          h: parseInt(l.getAttribute("height"))
        };
        e.framesCanvasTab = [];
        e._0x12f8e2(l, s, e._0x4ab4f7);
      });
    });
  },
  _0x12f8e2: function (t, e) {
    const i = this;
    const n = "-" + 1 / (i._0x4ab4f7.nbFrames - 1) * i.framesCanvasTab.length + "s";
    i._0xbfd979(t, "paused", n);
    const a = document.createElement("canvas");
    a.width = e.w;
    a.height = e.h;
    i._0xe8c147(t, 0, 0, a, function (n) {
      i.framesCanvasTab.push(n);
      if (i.framesCanvasTab.length == i._0x4ab4f7.nbFrames) {
        if (i._0x4ab4f7.smartCrop) {
          i.framesCanvasTab = i._0x3d00d8(i.framesCanvasTab);
        }
        if (i.framesCanvasTab) {
          i._0x4ab4f7.onSuccess(i.framesCanvasTab);
        }
      } else {
        i._0x12f8e2(t, e);
      }
    });
  },
  _0x46869d: function (t) {
    for (const e of Object.keys(t)) {
      this._0x4ab4f7[e] = t[e];
    }
    if (this._0x4ab4f7.smartCrop === true) {
      this._0x4ab4f7.smartCrop = {
        x: 2,
        y: 2
      };
    }
  },
  _0x3d00d8: function (t) {
    const e = this;
    const i = document.createElement("canvas");
    const n = t.length;
    const a = t[0].width;
    const o = t[0].height;
    i.width = a;
    i.height = o;
    for (let e = 0; e < n; e++) {
      i.getContext("2d").drawImage(t[e], 0, 0);
    }
    const l = TextEditorUtil.trimCanvas(i, true, 1);
    if (l.w == 0 || l.h == 0) {
      e._0x4ab4f7.onError(TextEditorUtil.getText("error-creating-animation"));
      return false;
    }
    if (l.w != a || l.h != o) {
      let e;
      for (let i = 0; i < n; i++) {
        e = document.createElement("canvas");
        e.width = l.w;
        e.height = l.h;
        e.getContext("2d").drawImage(t[i], l.x, l.y, l.w, l.h, 0, 0, l.w, l.h);
        t[i] = e;
      }
    }
    return t;
  },
  _0x2795cf: function (t) {
    const e = this;
    let i = e._0x1e23ad();
    if (i) {
      t(i);
    } else {
      var n = document.getElementsByTagName("head")[0];
      var a = document.createElement("link");
      a.rel = "stylesheet";
      a.type = "text/css";
      a.onload = function () {
        t(e._0x1e23ad());
      };
      a.onerror = function () {
        if (e._0x4ab4f7.onError) {
          e._0x4ab4f7.onError(TextEditorUtil.getText("error-css-animation-file") + "\n" + e._0x4ab4f7.cssFile);
        }
      };
      a.href = url(e._0x4ab4f7.cssFile);
      a.media = "all";
      n.appendChild(a);
    }
  },
  _0x5d3436: function (t, e, i, n) {
    let a;
    let o;
    let l;
    let s = {
      x: 1,
      y: 1
    };
    const r = t.querySelector("image");
    const d = t.querySelector("g");
    const c = parseInt(t.getAttribute("data-original-width"));
    const u = parseInt(t.getAttribute("data-original-height"));
    if (e !== -1 && (c > e || u > e)) {
      l = c > u ? e / c : e / u;
      a = l * c;
      o = l * u;
    } else {
      a = c;
      o = u;
    }
    if (n > 0) {
      const t = {
        x: n * a,
        y: n * a
      };
      s = {
        x: a / (a + t.x * 2),
        y: a / (a + t.y * 2)
      };
      a += t.x * 2;
      o += t.y * 2;
    }
    t.setAttribute("viewBox", "0 0 " + a + " " + o);
    r.setAttribute("width", a + "px");
    r.setAttribute("height", o + "px");
    if (i) {
      const e = Math.max(a, o);
      t.setAttribute("width", e * i.x + "px");
      t.setAttribute("height", e * i.y + "px");
    } else {
      t.setAttribute("width", a + "px");
      t.setAttribute("height", o + "px");
    }
    d.setAttribute("transform", "translate(" + a / 2 + " " + o / 2 + ") rotate(0) scale(" + s.x + " " + s.y + ") translate(-" + a / 2 + " -" + o / 2 + ")");
    d.replaceWith(d);
    return {
      w: a,
      h: o
    };
  },
  _0xbfd979: function (t, e, i) {
    const n = t.querySelector("image");
    const a = t.querySelector("g");
    t.style.animationPlayState = n.style.animationPlayState = a.style.animationPlayState = e;
    t.style.animationDelay = n.style.animationDelay = a.style.animationDelay = i;
  },
  _0x4dee42: function (t, e) {
    const i = "animate-image-" + TextEditorUtil.generateUUID();
    return "<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"100px\" height=\"100px\" viewBox=\"0 0 100 100\" style=\"background: rgba(255, 255, 255, 0); image-rendering: auto;\"><g style=\"\"><image x=\"0\" y=\"0\" width=\"100\" height=\"100\" style=\"transform-origin:center center; animation: 1s linear 0s infinite normal none running " + i + ";\" href=\"" + e + "\"></image></g><style id=\"" + i + "\" style=\"animation-play-state: running; animation-delay: 0.0s;\">@keyframes " + i + " {" + t + "}</style></svg>";
  },
  _0xe8c147: function (t, e, i, n, a) {
    const o = new XMLSerializer().serializeToString(t);
    const l = document.createElement("img");
    const s = "data:image/svg+xml;base64," + btoa(o);
    l.onload = function () {
      setTimeout(function () {
        n.getContext("2d").drawImage(l, e, i);
        a(n);
      }, 20);
    };
    l.onerror = function (t) {};
    l.src = s;
  },
  _0x273966: function (t) {
    const e = this;
    const i = e._0x1e23ad();
    if (i) {
      for (const e of i) {
        regex = new RegExp("keyframes\\s+ld-" + t + "\\s*\\{", "s");
        if (regex.test(e.cssText)) {
          regex = /keyframes\s+[\w-]+\s*\{(.*)\}/s;
          const t = e.cssText.match(regex);
          if (t) {
            return t[1].trim();
          }
        }
      }
    }
    if (e._0x4ab4f7.onError) {
      e._0x4ab4f7.onError(TextEditorUtil.getText("error-css-animation-effect") + "\n" + t);
    }
    return false;
  },
  _0x4a45ff: function (t, e, i, n) {
    if (["blur"].indexOf(t) === -1) {
      return e;
    }
    if (t === "blur") {
      regex = /([0-9\.]+px)/g;
      const t = e.match(regex);
      t.sort(function (t, e) {
        return e.length - t.length;
      });
      const n = 1200;
      const a = 70;
      const o = TextEditorUtil.exponentialCurve(10, 1, 6.5).reverse()[Math.ceil(Math.min(i, n) / n * 10) - 1];
      const l = Math.round(o * a);
      for (let i = 0; i < t.length; i++) {
        if (!(parseFloat(t[i]) <= 0)) {
          e = e.replace(t[i], l + "px");
        }
      }
    }
    return e;
  },
  _0x1e23ad: function () {
    let t = document.styleSheets;
    for (let e = 0; e < t.length; e++) {
      let i = new RegExp(this._0x4ab4f7.cssFile, "i");
      if (t[e].href != null && i.test(t[e].href)) {
        const i = t[e].cssRules;
        if (i != null && i.length > 0) {
          return i;
        }
      }
    }
    return false;
  },
  _0x53d75e: function (t, e, i) {
    const n = this;
    const a = new Image();
    a.crossOrigin = "Anonymous";
    a.onload = function () {
      const t = document.createElement("canvas");
      const n = t.getContext("2d");
      let a;
      if (e !== -1 && (this.naturalWidth > e || this.naturalHeight > e)) {
        a = this.naturalWidth > this.naturalHeight ? e / this.naturalWidth : e / this.naturalHeight;
        w = a * this.naturalWidth;
        h = a * this.naturalHeight;
      } else {
        w = this.naturalWidth;
        h = this.naturalHeight;
      }
      let o = Math.min(2, this.naturalWidth / w, this.naturalHeight / h);
      w *= o;
      h *= o;
      t.width = w;
      t.height = h;
      n.drawImage(this, 0, 0, w, h);
      i(t.toDataURL(), w, h);
    };
    a.onerror = function () {
      if (n._0x4ab4f7.onError) {
        n._0x4ab4f7.onError(TextEditorUtil.getText("error-reading-image") + " (" + t + ")");
      }
    };
    a.src = t;
  },
  _0x443ea4: function (t) {
    var e = document.createElement("template");
    t = t.trim();
    e.innerHTML = t;
    return e.content.firstChild;
  }
};
let drawPostTreatmentTimer;
let drawTimer;
let textEditorControls;
let editorDrawing = false;
function _drawManager(t, e, i = {}) {
  if (drawPostTreatmentTimer) {
    clearTimeout(drawPostTreatmentTimer);
  }
  if (drawTimer) {
    clearTimeout(drawTimer);
  }
  if (i.isPostTreatment === undefined) {
    i.isPostTreatment = false;
  }
  drawTimer = t.drawing ? setTimeout(n => {
    _drawManager(t, e, i);
  }, 100) : setTimeout(async n => {
    if (t.drawing) {
      _drawManager(...arguments);
    } else {
      try {
        t.setConfig(e);
        await t.draw(i);
      } catch (e) {
        t.drawing = false;
        if (textEditorControls) {
          textEditorControls.onDrawFinish();
        }
        console.log(e);
      }
      if (!i.isPostTreatment && t.needPostTreatment) {
        drawPostTreatmentTimer = setTimeout(i => {
          _drawManager(t, e, {
            isPostTreatment: true
          });
        }, 600);
      }
    }
  }, 10);
}
function _onControlChanged(t, e, i, n) {
  t.setConfig(e);
  if (i) {
    _drawManager(t, e, n);
  }
}
function _loadPreset(t, e, i = null) {
  if (i) {
    t = TextEditorUtil.mergeDeep(t, i);
  }
  let n = e.textEditor;
  if (!n) {
    const i = getById("tt-canvas");
    getById("tt-canvas-container");
    n = new TextEditor(i);
    n.setConfig(t);
    n.on("drawStart", () => {
      e.onDrawStart();
    });
    n.on("drawFinish", () => {
      e.onDrawFinish();
    });
    e._0x23392d(n);
    e.on("controlChanged", _onControlChanged);
  }
  const a = n.setConfig(t);
  _drawManager(n, a, {
    forceWaitOpenCV: true,
    forceWaitDistortScript: true,
    isPostTreatment: true
  });
  e._0x2ca34f(a);
}
function _fetchPreset(t) {
  return new Promise(async (e, i) => {
    const n = t => {
      if (t < 3) {
        a(t);
      } else {
        alert(TextEditorUtil.getText("error-loading-preset-config-file"));
        e({});
      }
    };
    const a = i => {
      i++;
      fetch(t).then(async t => {
        if (t.ok) {
          const i = await t.json();
          e(i);
        } else {
          console.error(t);
          n(i);
        }
      }).catch(t => {
        console.error(t);
        n(i);
      });
    };
    a(0);
  });
}
function _setDownloadPresetPopup(t, e, i, n) {
  const a = getById("tt-download-preset-popup");
  if (!a) {
    return;
  }
  const o = getById("tt-download-preset-popup-remember-input");
  a.addEventListener("click", function (t) {
    if (t.target === this || t.target.classList.contains("tt-close")) {
      a.classList.add("hide");
    }
  });
  const l = async l => {
    a.classList.add("hide");
    i.setLoadingInterface(true);
    i.setLoadingCanvas(true);
    _loadPreset(await _fetchPreset(e), i, n);
    i.setLoadingInterface(false);
    if (typeof Storage != "undefined") {
      localStorage.setItem("preset" + t + "AlreadyDownloaded", true);
      if (o?.checked) {
        localStorage.setItem("autoDownloadPresets", true);
      }
    }
  };
  const s = a.querySelector(".tt-download-preset-button");
  if (s) {
    s.addEventListener("click", l);
  }
  const r = a.querySelector(".tt-preview img");
  if (r) {
    r.addEventListener("click", l);
  }
  a.classList.remove("hide");
}
function _showDownloadPresetPopup(t, e) {
  if (!t) {
    return false;
  }
  if (typeof Storage != "undefined" && localStorage.getItem("autoDownloadPresets")) {
    return false;
  }
  let i = tt.getAttribute("data-preset-filesize");
  i = i ? parseInt(i) : 0;
  let n = i && i / 1024 > 512;
  if (n && typeof Storage != "undefined") {
    n = localStorage.getItem("preset" + t + "AlreadyDownloaded") === null;
  }
  return n;
}
function _setPremiumRestricted() {
  const t = $("#tt");
  if (t.getAttribute("data-pl")) {
    t.classList.add("tt-premium-restricted");
    setInterval(t => {
      const e = $("#tt-premium-layer");
      if (!e || !e.style.display.includes("", "block")) {
        $("body").innerHTML = "";
      }
    }, 500);
  }
}
async function __ready(t) {
  const e = Date.now() / 1000;
  let i = false;
  while (true) {
    i = true;
    for (const t of EDITOR_READY_FUNC) {
      if (window[t] === undefined) {
        i = false;
        break;
      }
    }
    if (!["complete", "interactive"].includes(document.readyState)) {
      i = false;
    }
    if (i) {
      t();
      return;
    }
    if (Date.now() / 1000 - e > 120) {
      alert("You seem to have problems with your Internet connection. Please refresh the page.");
      break;
    }
    await new Promise(t => setTimeout(t, 100));
  }
}
__ready(async t => {
  const e = getById("tt");
  textEditorControls = new TextEditorControls();
  textEditorControls.setLoadingInterface(true);
  const i = e.getAttribute("data-preset-id");
  const n = e.getAttribute("data-preset-url");
  const a = await _showDownloadPresetPopup(i);
  let o;
  const l = e.getAttribute("data-preset-config");
  if (l) {
    try {
      o = JSON.parse(l);
    } catch (t) {
      console.error(TextEditorUtil.getText("error-decoding-preset-config-file"));
    }
  }
  let s = {};
  if (n && !a) {
    s = await _fetchPreset(n);
  }
  _loadPreset(s, textEditorControls, o);
  textEditorControls.setLoadingInterface(false);
  if (a) {
    _setDownloadPresetPopup(i, n, textEditorControls, o);
  }
  _setPremiumRestricted();
});